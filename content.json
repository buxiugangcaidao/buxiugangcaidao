{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-06-27T06:02:15.000Z","updated":"2021-06-27T06:44:30.897Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"revenue","slug":"the first & twelfth","date":"2021-07-21T16:11:59.000Z","updated":"2021-07-25T03:04:42.667Z","comments":true,"path":"2021/07/22/the first & twelfth/","link":"","permalink":"http://example.com/2021/07/22/the%20first%20&%20twelfth/","excerpt":"相亲认识了一个人 见到她的第一眼，她就露出了像花儿一样的笑容，眼睛弯成一道月亮的形状 我不知道她是笑什么，我只是觉得很美妙 虽然是第一次见面，但是彼此都出乎意料的健谈，完全不像是第一次见面的陌生人，虽然谈论的话题并不深刻，但是恰恰是日常生活的交流让我感觉到我们好像在很久之前就应该认识了，这一次更像是久别重逢 今天是我们的第二次见面，有些爆炸，反思中……","text":"相亲认识了一个人 见到她的第一眼，她就露出了像花儿一样的笑容，眼睛弯成一道月亮的形状 我不知道她是笑什么，我只是觉得很美妙 虽然是第一次见面，但是彼此都出乎意料的健谈，完全不像是第一次见面的陌生人，虽然谈论的话题并不深刻，但是恰恰是日常生活的交流让我感觉到我们好像在很久之前就应该认识了，这一次更像是久别重逢 今天是我们的第二次见面，有些爆炸，反思中……","categories":[{"name":"diary","slug":"diary","permalink":"http://example.com/categories/diary/"}],"tags":[]},{"title":"习题之一元一次方程","slug":"习题之一元一次方程","date":"2021-07-19T18:43:58.000Z","updated":"2021-07-23T11:04:22.639Z","comments":true,"path":"2021/07/20/习题之一元一次方程/","link":"","permalink":"http://example.com/2021/07/20/%E4%B9%A0%E9%A2%98%E4%B9%8B%E4%B8%80%E5%85%83%E4%B8%80%E6%AC%A1%E6%96%B9%E7%A8%8B/","excerpt":"问题背景：实现一元一次方程的计算，例如：input：3a+3=9output:a=2 note:给出的一元一次方程中没有括号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 20-Jul-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 23-Jul-2021 *//*//实现解一元一次方程//step1 接收输入，并转换成需要的数据格式//step2 算法实现//step3 输出结果，并清理程序资源1 接收的输入格式为一行字符串，选择将其存储在数组中 声明需要的数组资源，类型大小； 使用getc函数接收输入并存储在数组中； 当接收到‘\\n’时表示结束； 将存储在数组中的输入打印出来检测是否正确；2 算法思路就是将一元一次表达式转换为AX+B=0的形式。然后直接计算X=-(B/A)即可； 因此需要遍历表达式中的元素进行区分合并同类项，根据项的特点可以将数组中存储的内容分为三类，分别是符号、数字和字母；实现时根据ASCII码进行区分； 此处设计两个栈，A栈和B栈，分别存储计算系数A和B时的元素，将数组中的元素从右到左遍历， 1 若元素是字母则表示该项为AX，即需要把当前栈指向A栈，否则指向B栈 2 若元素是数字，则直接存入当前栈 3 若元素是符号，则更新符号变量，并计算当前栈内元素组成的数字大小，累加到系数A或B，然后清空当前栈并释放当前栈*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;int StoreInput(char *arr, int size)&#123; for(int loop = 0; loop &lt; size; loop++) &#123; scanf(&quot;%c&quot;, arr+loop); if(*(arr+loop) == &#x27;\\n&#x27;) &#123; //printf(&quot;%s&quot;, arr); return loop; &#125; &#125; printf(&quot;The input is too long!\\n&quot;); return 0;&#125;typedef struct node&#123; int num; struct node* next;&#125;node;void NodeFree(node* head)&#123; node* tNode; while(head-&gt;next != NULL) &#123; tNode = head-&gt;next; free(head); head = tNode; &#125; return;&#125;node* GetCurNode(node* head)&#123; node* temp = head; while(temp-&gt;next != NULL) &#123; temp = temp-&gt;next; &#125; return temp;&#125;void NodePush(node* head, int num)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return; &#125; node* curNode = GetCurNode(head); node* nextNode = (node*)malloc(sizeof(node)); nextNode-&gt;num = num; nextNode-&gt;next = NULL; curNode-&gt;next = nextNode;&#125;int NodePop(node* head)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return -1; &#125; int popNum = 0; node* prevNode = head; if(prevNode-&gt;next == NULL) &#123; popNum = prevNode-&gt;num; //printf(&quot;%d\\n&quot;, popNum); free(prevNode); return popNum; &#125; node* relNode = prevNode-&gt;next; while(relNode-&gt;next != NULL) &#123; prevNode = prevNode-&gt;next; relNode = prevNode-&gt;next; &#125; popNum = relNode-&gt;num; //printf(&quot;%d\\n&quot;, popNum); free(relNode); prevNode-&gt;next = NULL; return popNum;;&#125;void NodePrint(node* head)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return; &#125; node* curNode = head; //printf(&quot;0x%lx:&quot;, (unsigned long)head); //printf(&quot;%d\\n&quot;, curNode-&gt;num); while(curNode-&gt;next != NULL) &#123; //printf(&quot;0x%lx:&quot;, (unsigned long)curNode-&gt;next); //printf(&quot;%d\\n&quot;, curNode-&gt;next-&gt;num); curNode = curNode-&gt;next; &#125;&#125;int char2Int(char c)&#123; return (int)(c-&#x27;0&#x27;);&#125;char Int2Char(int num)&#123; return (char)(num+&#x27;0&#x27;);&#125;void calcCoef(node* head, int pos, double* coefA, double* coefB, char* unKownNum)&#123; node stackA, stackB; stackA.num = 0; stackA.next = NULL; stackB.num = 0; stackB.next = NULL; node* curStack = &amp;stackB; char popNum; int curStackLen = 0, coefSym = -1; for(int loop = pos; loop &gt; 0; loop--) &#123; popNum = (char)NodePop(head); //printf(&quot;loop:%d\\tnum:%c\\n&quot;, loop, Int2Char(popNum)); if((Int2Char(popNum) &gt;= &#x27;a&#x27;) &amp;&amp; (Int2Char(popNum) =&lt; &#x27;z&#x27;)) &#123; curStack = &amp;stackA; *unKownNum = Int2Char(popNum); if(loop == 1) *coefA += 1; continue; &#125; if((Int2Char(popNum) &lt;= &#x27;9&#x27;) &amp;&amp; (Int2Char(popNum) &gt;= &#x27;0&#x27;)) &#123; NodePush(curStack, (int)popNum); curStackLen++; if(loop == 1) &#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; //printf(&quot;last|temp:%d\\n&quot;, temp); if(curStack == &amp;stackA) &#123; *coefA += (coefSym) * temp; //printf(&quot;coefA:%f\\n&quot;, *coefA); &#125; if(curStack == &amp;stackB) &#123; *coefB += (coefSym) * temp; //printf(&quot;coefB:%f\\n&quot;, *coefB); &#125; NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; continue; &#125; if(Int2Char(popNum) == &#x27;=&#x27;) &#123; int temp = 0; //printf(&quot;curStackLen:%d\\n&quot;, curStackLen); for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; //printf(&quot;=|temp:%d\\n&quot;, temp); if(curStack == &amp;stackA) &#123; if(temp == 0) *coefA += (coefSym) * 1; *coefA += (coefSym) * temp; //printf(&quot;coefA:%f\\n&quot;, *coefA); &#125; if(curStack == &amp;stackB) &#123; *coefB += (coefSym) * temp; //printf(&quot;coefB:%f\\n&quot;, *coefB); &#125; NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; coefSym = 1; &#125; if(Int2Char(popNum) == &#x27;-&#x27;) &#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; //printf(&quot;-|temp:%d\\n&quot;, temp); if(curStack == &amp;stackA) &#123; if(temp == 0) &#123; *coefA += (coefSym) * (-1); &#125; *coefA += (coefSym) * (-1) * temp; //printf(&quot;coefA:%f\\n&quot;, *coefA); &#125; if(curStack == &amp;stackB) &#123; *coefB += (coefSym) * (-1)* temp; //printf(&quot;coefB:%f\\n&quot;, *coefB); &#125; //printf(&quot;coefA:%f\\ncoefB:%f\\n&quot;, *coefA, *coefB); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; if(Int2Char(popNum) == &#x27;+&#x27;) &#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; //printf(&quot;+|temp:%d\\n&quot;, temp); if(curStack == &amp;stackA) &#123; if(temp == 0) &#123; *coefA += (coefSym) * 1; &#125; *coefA += (coefSym) * 1 * temp; //printf(&quot;coefA:%f\\n&quot;, *coefA); &#125; if(curStack == &amp;stackB) &#123; *coefB += (coefSym) * temp; //printf(&quot;coefB:%f\\n&quot;, *coefB); &#125; //printf(&quot;coefA:%f\\ncoefB:%f\\n&quot;, *coefA, *coefB); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; &#125;&#125;int main()&#123; char arr[30]; int pos; pos = StoreInput(arr, 30); node *head = (node*)malloc(sizeof(node)); head-&gt;num = 0; head-&gt;next = NULL; for(int loop = 0; loop &lt; pos; loop++) &#123; NodePush(head, char2Int(*(arr+loop))); &#125; double coefA = 0, coefB = 0; char unKownNum; calcCoef(head, pos, &amp;coefA, &amp;coefB, &amp;unKownNum); printf(&quot;A:%f\\nB:%f\\n&quot;, coefA, coefB); //printf(&quot;%c=%03f\\n&quot;, unKownNum, (float)(-coefB/coefA)); printf(&quot;\\n%.2f\\n&quot;, (-coefB/coefA)); NodeFree(head); free(head); return 0;&#125;","text":"问题背景：实现一元一次方程的计算，例如：input：3a+3=9output:a=2 note:给出的一元一次方程中没有括号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 20-Jul-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 23-Jul-2021 *//*//实现解一元一次方程//step1 接收输入，并转换成需要的数据格式//step2 算法实现//step3 输出结果，并清理程序资源1 接收的输入格式为一行字符串，选择将其存储在数组中 声明需要的数组资源，类型大小； 使用getc函数接收输入并存储在数组中； 当接收到‘\\n’时表示结束； 将存储在数组中的输入打印出来检测是否正确；2 算法思路就是将一元一次表达式转换为AX+B=0的形式。然后直接计算X=-(B/A)即可； 因此需要遍历表达式中的元素进行区分合并同类项，根据项的特点可以将数组中存储的内容分为三类，分别是符号、数字和字母；实现时根据ASCII码进行区分； 此处设计两个栈，A栈和B栈，分别存储计算系数A和B时的元素，将数组中的元素从右到左遍历， 1 若元素是字母则表示该项为AX，即需要把当前栈指向A栈，否则指向B栈 2 若元素是数字，则直接存入当前栈 3 若元素是符号，则更新符号变量，并计算当前栈内元素组成的数字大小，累加到系数A或B，然后清空当前栈并释放当前栈*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;int StoreInput(char *arr, int size)&#123; for(int loop = 0; loop &lt; size; loop++) &#123; scanf(&quot;%c&quot;, arr+loop); if(*(arr+loop) == &#x27;\\n&#x27;) &#123; //printf(&quot;%s&quot;, arr); return loop; &#125; &#125; printf(&quot;The input is too long!\\n&quot;); return 0;&#125;typedef struct node&#123; int num; struct node* next;&#125;node;void NodeFree(node* head)&#123; node* tNode; while(head-&gt;next != NULL) &#123; tNode = head-&gt;next; free(head); head = tNode; &#125; return;&#125;node* GetCurNode(node* head)&#123; node* temp = head; while(temp-&gt;next != NULL) &#123; temp = temp-&gt;next; &#125; return temp;&#125;void NodePush(node* head, int num)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return; &#125; node* curNode = GetCurNode(head); node* nextNode = (node*)malloc(sizeof(node)); nextNode-&gt;num = num; nextNode-&gt;next = NULL; curNode-&gt;next = nextNode;&#125;int NodePop(node* head)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return -1; &#125; int popNum = 0; node* prevNode = head; if(prevNode-&gt;next == NULL) &#123; popNum = prevNode-&gt;num; //printf(&quot;%d\\n&quot;, popNum); free(prevNode); return popNum; &#125; node* relNode = prevNode-&gt;next; while(relNode-&gt;next != NULL) &#123; prevNode = prevNode-&gt;next; relNode = prevNode-&gt;next; &#125; popNum = relNode-&gt;num; //printf(&quot;%d\\n&quot;, popNum); free(relNode); prevNode-&gt;next = NULL; return popNum;;&#125;void NodePrint(node* head)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return; &#125; node* curNode = head; //printf(&quot;0x%lx:&quot;, (unsigned long)head); //printf(&quot;%d\\n&quot;, curNode-&gt;num); while(curNode-&gt;next != NULL) &#123; //printf(&quot;0x%lx:&quot;, (unsigned long)curNode-&gt;next); //printf(&quot;%d\\n&quot;, curNode-&gt;next-&gt;num); curNode = curNode-&gt;next; &#125;&#125;int char2Int(char c)&#123; return (int)(c-&#x27;0&#x27;);&#125;char Int2Char(int num)&#123; return (char)(num+&#x27;0&#x27;);&#125;void calcCoef(node* head, int pos, double* coefA, double* coefB, char* unKownNum)&#123; node stackA, stackB; stackA.num = 0; stackA.next = NULL; stackB.num = 0; stackB.next = NULL; node* curStack = &amp;stackB; char popNum; int curStackLen = 0, coefSym = -1; for(int loop = pos; loop &gt; 0; loop--) &#123; popNum = (char)NodePop(head); //printf(&quot;loop:%d\\tnum:%c\\n&quot;, loop, Int2Char(popNum)); if((Int2Char(popNum) &gt;= &#x27;a&#x27;) &amp;&amp; (Int2Char(popNum) =&lt; &#x27;z&#x27;)) &#123; curStack = &amp;stackA; *unKownNum = Int2Char(popNum); if(loop == 1) *coefA += 1; continue; &#125; if((Int2Char(popNum) &lt;= &#x27;9&#x27;) &amp;&amp; (Int2Char(popNum) &gt;= &#x27;0&#x27;)) &#123; NodePush(curStack, (int)popNum); curStackLen++; if(loop == 1) &#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; //printf(&quot;last|temp:%d\\n&quot;, temp); if(curStack == &amp;stackA) &#123; *coefA += (coefSym) * temp; //printf(&quot;coefA:%f\\n&quot;, *coefA); &#125; if(curStack == &amp;stackB) &#123; *coefB += (coefSym) * temp; //printf(&quot;coefB:%f\\n&quot;, *coefB); &#125; NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; continue; &#125; if(Int2Char(popNum) == &#x27;=&#x27;) &#123; int temp = 0; //printf(&quot;curStackLen:%d\\n&quot;, curStackLen); for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; //printf(&quot;=|temp:%d\\n&quot;, temp); if(curStack == &amp;stackA) &#123; if(temp == 0) *coefA += (coefSym) * 1; *coefA += (coefSym) * temp; //printf(&quot;coefA:%f\\n&quot;, *coefA); &#125; if(curStack == &amp;stackB) &#123; *coefB += (coefSym) * temp; //printf(&quot;coefB:%f\\n&quot;, *coefB); &#125; NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; coefSym = 1; &#125; if(Int2Char(popNum) == &#x27;-&#x27;) &#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; //printf(&quot;-|temp:%d\\n&quot;, temp); if(curStack == &amp;stackA) &#123; if(temp == 0) &#123; *coefA += (coefSym) * (-1); &#125; *coefA += (coefSym) * (-1) * temp; //printf(&quot;coefA:%f\\n&quot;, *coefA); &#125; if(curStack == &amp;stackB) &#123; *coefB += (coefSym) * (-1)* temp; //printf(&quot;coefB:%f\\n&quot;, *coefB); &#125; //printf(&quot;coefA:%f\\ncoefB:%f\\n&quot;, *coefA, *coefB); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; if(Int2Char(popNum) == &#x27;+&#x27;) &#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; //printf(&quot;+|temp:%d\\n&quot;, temp); if(curStack == &amp;stackA) &#123; if(temp == 0) &#123; *coefA += (coefSym) * 1; &#125; *coefA += (coefSym) * 1 * temp; //printf(&quot;coefA:%f\\n&quot;, *coefA); &#125; if(curStack == &amp;stackB) &#123; *coefB += (coefSym) * temp; //printf(&quot;coefB:%f\\n&quot;, *coefB); &#125; //printf(&quot;coefA:%f\\ncoefB:%f\\n&quot;, *coefA, *coefB); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; &#125;&#125;int main()&#123; char arr[30]; int pos; pos = StoreInput(arr, 30); node *head = (node*)malloc(sizeof(node)); head-&gt;num = 0; head-&gt;next = NULL; for(int loop = 0; loop &lt; pos; loop++) &#123; NodePush(head, char2Int(*(arr+loop))); &#125; double coefA = 0, coefB = 0; char unKownNum; calcCoef(head, pos, &amp;coefA, &amp;coefB, &amp;unKownNum); printf(&quot;A:%f\\nB:%f\\n&quot;, coefA, coefB); //printf(&quot;%c=%03f\\n&quot;, unKownNum, (float)(-coefB/coefA)); printf(&quot;\\n%.2f\\n&quot;, (-coefB/coefA)); NodeFree(head); free(head); return 0;&#125;","categories":[{"name":"习题","slug":"习题","permalink":"http://example.com/categories/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}]},{"title":"添加封面图片","slug":"添加封面图片","date":"2021-06-27T11:06:58.000Z","updated":"2021-07-04T09:28:13.952Z","comments":true,"path":"2021/06/27/添加封面图片/","link":"","permalink":"http://example.com/2021/06/27/%E6%B7%BB%E5%8A%A0%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%89%87/","excerpt":"","text":"","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"HELLO WORLD","slug":"hello-world","date":"2021-06-26T05:01:37.141Z","updated":"2021-07-04T09:17:45.955Z","comments":true,"path":"2021/06/26/hello-world/","link":"","permalink":"http://example.com/2021/06/26/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"手把手教你写Makefile和CMakelists.txt","slug":"欢迎来到我的网络世界","date":"2021-06-25T15:22:55.000Z","updated":"2021-06-29T13:42:53.367Z","comments":true,"path":"2021/06/25/欢迎来到我的网络世界/","link":"","permalink":"http://example.com/2021/06/25/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B8%96%E7%95%8C/","excerpt":"入职后开始接触了Linux环境下的代码，而且是一个代码量10W+的巨型工程，刚面对这样打的项目时总是对其中重重的文件目录感到惊讶，这么多的文件是怎么变成最后的可执行文件的？ 之前在学校或者个人学习的时候写的代码都是比较简单的，一个目录下若干个c文件，编译时直接使用gcc工具一步执行gcc main.c -o main就完事了，但是面对这种多目录多源文件的项目如果还使用这种方法的话明显生产效率是极低的。由于不同的项目在进行编译时都使用相同的编译指令，只是路径和文件名不同，所以自然想到应该可以编写脚本实现编译自动化，经过学习发现原来有一种专门的脚本语言用来解决这件事，就是今天学习的内容Makefile和CMakelists.txt。 什么是Makefile首先说下Makefile，Makefile就是包含编译指令的一个脚本，Makefile需要和make搭配使用，make是Linux平台下的一个工具，通过它可以执行Makefile中的编译指令以完成工程的编译。make和Makefile的关系可以用bash和shell脚本做类比，脚本中按照脚本的规定语法写好了一些指令，然后通过对应的执行命令将脚本中的一系列指令执行完成。 接下来我们就来看下书写Makefile脚本的语法规则吧，首先我们都知道生成一个可执行文件需要有源文件，而源文件多数也都需要依赖文件，例如头文件等，Makefile中也必须遵循这样的原则。 makefile的语法规则之一就是：(以C语言项目为例，使用GCC工具，如果是C++项目则使用G++工具) targetFile:sourceFilegcc -[E][S][C][ ] sourceFile -o targetFile # gcc -E 表示只进行预编译，得到的目标文件为后缀为i的预编译文件（预编译执行的操作包括头展开，宏替换以及条件编译优化） # gcc -S 表示进行预编译和汇编，得到后缀为s的汇编文件（汇编将预编译的代码转换为汇编代码）","text":"入职后开始接触了Linux环境下的代码，而且是一个代码量10W+的巨型工程，刚面对这样打的项目时总是对其中重重的文件目录感到惊讶，这么多的文件是怎么变成最后的可执行文件的？ 之前在学校或者个人学习的时候写的代码都是比较简单的，一个目录下若干个c文件，编译时直接使用gcc工具一步执行gcc main.c -o main就完事了，但是面对这种多目录多源文件的项目如果还使用这种方法的话明显生产效率是极低的。由于不同的项目在进行编译时都使用相同的编译指令，只是路径和文件名不同，所以自然想到应该可以编写脚本实现编译自动化，经过学习发现原来有一种专门的脚本语言用来解决这件事，就是今天学习的内容Makefile和CMakelists.txt。 什么是Makefile首先说下Makefile，Makefile就是包含编译指令的一个脚本，Makefile需要和make搭配使用，make是Linux平台下的一个工具，通过它可以执行Makefile中的编译指令以完成工程的编译。make和Makefile的关系可以用bash和shell脚本做类比，脚本中按照脚本的规定语法写好了一些指令，然后通过对应的执行命令将脚本中的一系列指令执行完成。 接下来我们就来看下书写Makefile脚本的语法规则吧，首先我们都知道生成一个可执行文件需要有源文件，而源文件多数也都需要依赖文件，例如头文件等，Makefile中也必须遵循这样的原则。 makefile的语法规则之一就是：(以C语言项目为例，使用GCC工具，如果是C++项目则使用G++工具) targetFile:sourceFilegcc -[E][S][C][ ] sourceFile -o targetFile # gcc -E 表示只进行预编译，得到的目标文件为后缀为i的预编译文件（预编译执行的操作包括头展开，宏替换以及条件编译优化） # gcc -S 表示进行预编译和汇编，得到后缀为s的汇编文件（汇编将预编译的代码转换为汇编代码） # gcc -c 表示进行预编译、汇编和编译，得到后缀为o的二进制文件（编译将汇编代码转换为二进制机器语言） # gcc不带参数表示直接进行预编译、汇编、编译和链接，得到可执行文件 其中第一行定义了目标文件和源文件，中间用冒号隔开，第二行先用TAB键置空位，然后给出了具体的实现指令。 该命令只有在目标文件不存在，或目标比依赖的文件更旧，才会被执行。 当我们的工程中在同一目录下出现了多个C源文件时，则需重复上面两行指令依次生成.o文件最后链接成可执行文件。那么为了减少这种重复度极高的代码的书写，makefile语法中提供了一种设置替换的方式，可以将所有的同类型文件用一个变量来表示。 OBJ=a.o b.o c.o TAR=main 这样Makefile中所有出现a.o b.o c.o的地方就都可以用$(OBJ)来代替，所有出现main的地方都可以用$(TAR)表示，$(变量名)为变量的使用方式。 另外还可以用+=进行追加使变量可以适用于不同的场景。:=则表示恒等于，使用恒等于设置的变量就不能在进行追加了。 除此以外，还有一些固定变量，**%.c表示任意的.c文件，%.o表示任意的.o文件， .c表示所有的.c文件，.o表示所有的.o文件，$@表示所有的目标文件，$^表示所有的依赖文件，$&lt;表示所有依赖文件的第一个**。 通过这些变量使得我们的Makefile大大精简，同时还增强了Makefile在不同工程下的适用性。 最后在Makefile文件中还会集成一些和编译无关的操作我们希望在进行编译时或之前或之后同时进行的，例如编译之前先清除遗留的中间文件而重新生成覆盖，Makefile同样提供了一种伪目标的方式来实现。 .PHONY:clear clear: rm -rf main.o main .PHONY后面的target（即冒号之前的文件）表示的也是一个伪造的target, 而不是真实存在的文件target 总结一下，Makefile的编写其实就包括三步，第一步，指定目标文件和依赖文件；第二步，给出从依赖文件到目标文件的实现指令；第三步，进行变量替换； 华丽的分割线 CMakelists.txt又是什么东西?因为不同平台下的Makefile书写规则是不一样的，Makefile只适用于类UNIX系统下的编译，如果是在Windows环境下则需要重新编写Makefile。cmake就是为了解决跨平台编译的问题，使用cmake工具，可以自动生成适应平台的Makefile。 同样的，在单目录的场景下，CMakelists.txt的语法如下 CMAKE_MINIMUM_REQUIRED(3.10) PROJECT(main) AUX_SOURCE_DIR(./ DIR_SRC) ADD_EXECUTABLE(main ${DIR_SRC}) 只需要三行代码，第一行指定支持的cmake最低版本；第二行给工程命名；第三行将目录下所有源文件打包成变量，第四行生成可执行文件； 如果是多目录下，比如一个库文件目录和一个源文件目录的话，则需要在每个目录下面都编写一个CMakeLists.txt，一共三个，分别是源文件目录，库文件目录和根目录 其中源文件目录src下的CMakeListx.txt内容如下 AUX_SOURCE_DIRECTORY(./ DIR_SRC) ADD_EXECUTABLE(main ${DIR_SRC}) TARGET_LINK_LIBRARIES(main mylib) 库文件目录mylib下面的CMakeLists.txt内容如下 AUX_SOURCE_DIRECTORY(./ DIR_LIB) ADD_LIBRARY(mylib ${DIR_LIB}) 根目录下的CMakeLists.txt内容如下 CMAKE_MINIMUM_REQUIRED(3.10) PROJECT(main) ADD_SUBDIRECTORY(./src) ADD_SUBDIRECTORY(./mylib) 这是库目录和源文件目录分离的场景，如果说只有一个源文件没必要新建一个源文件目录即不存在源文件目录的情况下，库目录下的CMakeLists.txt不变，根目录下的CMakeLists.txt内容如下 CMAKE_MINIMUM_REQUIRED(3.10) PROJECT(main) ADD_SUBDIRECTORY(./mylib) AUX_SOURCE_DIRECTORY(./ DIR_SRC) ADD_EXECUTABLE(main ${DIR_SRC}) TARGET_LINK_LIBRARIES(main mylib) 实际上就是把原来根目录和源文件目录下的CMakeLists.txt合并了 以上是自己学习CMake的一点学习记录，总结下来发现也完全不难，只需要理解两个场景单目录和多目录下的编写方式就可以了，关键的语法不超过10行，CMake的知识点还有很多，具体详情可以在网上搜索。总之，CMake可以让我们不用去编写复杂的Makefile，并且跨平台，是个非常强大并值得一学的工具。 如果有写的不对的地方，希望能留言指正，谢谢阅读。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"编译技术","slug":"编译技术","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"}]}],"categories":[{"name":"diary","slug":"diary","permalink":"http://example.com/categories/diary/"},{"name":"习题","slug":"习题","permalink":"http://example.com/categories/%E4%B9%A0%E9%A2%98/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"编译技术","slug":"编译技术","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"}]}