{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-06-27T06:02:15.000Z","updated":"2021-06-27T06:44:30.897Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"红黑树","slug":"红黑树","date":"2021-10-17T12:14:51.000Z","updated":"2021-11-06T10:49:06.998Z","comments":true,"path":"2021/10/17/红黑树/","link":"","permalink":"http://example.com/2021/10/17/%E7%BA%A2%E9%BB%91%E6%A0%91/","excerpt":"手撕红黑树红黑树的应用场景红黑树的概念及原理红黑树的实现基础操作左旋右旋变色插入节点删除节点","text":"手撕红黑树红黑树的应用场景红黑树的概念及原理红黑树的实现基础操作左旋右旋变色插入节点删除节点查找、比较节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 17-Oct-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 28-Oct-2021 */ #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; #include&lt;stdarg.h&gt; //#include&lt;thread.h&gt; #define likely(x) __builtin_expect(!!(x), 1) //gcc内置函数, 帮助编译器分支优化 #define unlikely(x) __builtin_expect(!!(x), 0) #define RED 1 #define BLACK 2 #define NODENUM 1000000 int gPrintSwitch = 0; #define printf if(gPrintSwitch) printf typedef struct RbTreeNode &#123; struct RbTreeNode *left; struct RbTreeNode *right; struct RbTreeNode *parent; unsigned char color; int key; void *value; &#125;RbTreeNode; typedef struct RbTree &#123; RbTreeNode *root; RbTreeNode *nil; &#125;RbTree; RbTreeNode* AllocRbTreeNode() &#123; RbTreeNode *rbTreeNode = NULL; rbTreeNode = malloc(sizeof(RbTreeNode)); if(rbTreeNode == NULL) return NULL; memset(rbTreeNode, 0, sizeof(RbTreeNode)); return rbTreeNode; &#125; void DelRbTreeNode(RbTree *rbTree, RbTreeNode *delNode) &#123; if(delNode-&gt;parent == rbTree-&gt;nil) &#123; return; &#125; if(delNode == delNode-&gt;parent-&gt;left) &#123; delNode-&gt;parent-&gt;left = rbTree-&gt;nil; &#125; else &#123; delNode-&gt;parent-&gt;right = rbTree-&gt;nil; &#125; return; &#125; void LeftRotate(RbTree *rbTree, RbTreeNode *rotNode) &#123; RbTreeNode *rightNode = rotNode-&gt;right; rotNode-&gt;right = rightNode-&gt;left; if(rightNode-&gt;left != rbTree-&gt;nil) &#123; rightNode-&gt;left-&gt;parent = rotNode; &#125; if(rotNode-&gt;parent == rbTree-&gt;nil) &#123; rbTree-&gt;root = rightNode; &#125; else if(rotNode == rotNode-&gt;parent-&gt;left) &#123; rotNode-&gt;parent-&gt;left = rightNode; rightNode-&gt;parent = rotNode-&gt;parent; &#125; else &#123; rotNode-&gt;parent-&gt;right = rightNode; rightNode-&gt;parent = rotNode-&gt;parent; &#125; rightNode-&gt;left = rotNode; rotNode-&gt;parent = rightNode; return; &#125; void RightRotate(RbTree *rbTree, RbTreeNode *rotNode) &#123; RbTreeNode *leftNode = rotNode-&gt;left; rotNode-&gt;left = leftNode-&gt;right; if(leftNode-&gt;right != rbTree-&gt;nil) &#123; leftNode-&gt;right-&gt;parent = rotNode; &#125; if(rotNode-&gt;parent == rbTree-&gt;nil) &#123; rbTree-&gt;root = leftNode; &#125; else if(rotNode == rotNode-&gt;parent-&gt;left) &#123; rotNode-&gt;parent-&gt;left = leftNode; leftNode-&gt;parent = rotNode-&gt;parent; &#125; else &#123; rotNode-&gt;parent-&gt;right = leftNode; leftNode-&gt;parent = rotNode-&gt;parent; &#125; leftNode-&gt;right = rotNode; rotNode-&gt;parent = leftNode; &#125; void RbTreeInsertFixup(RbTree *rbTree, RbTreeNode *fixNode) &#123; while((fixNode-&gt;parent != rbTree-&gt;nil) &amp;&amp; (fixNode-&gt;parent-&gt;color == RED)) &#123; if(fixNode-&gt;parent == fixNode-&gt;parent-&gt;parent-&gt;left) &#123; RbTreeNode *y = fixNode-&gt;parent-&gt;parent-&gt;right; if((y != rbTree-&gt;nil) &amp;&amp; (y-&gt;color == RED)) &#123; fixNode-&gt;parent-&gt;color = BLACK; y-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; fixNode = fixNode-&gt;parent-&gt;parent; &#125; else &#123; // LL型--&gt;右旋 if(fixNode == fixNode-&gt;parent-&gt;left) &#123; fixNode-&gt;parent-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; RightRotate(rbTree, fixNode-&gt;parent-&gt;parent); &#125; //LR型--左旋+右旋 else &#123; fixNode-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; LeftRotate(rbTree, fixNode-&gt;parent); RightRotate(rbTree, fixNode-&gt;parent); &#125; &#125; &#125; else &#123; RbTreeNode *y = fixNode-&gt;parent-&gt;parent-&gt;left; if((y != rbTree-&gt;nil) &amp;&amp; (y-&gt;color == RED)) &#123; fixNode-&gt;parent-&gt;color = BLACK; y-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; fixNode = fixNode-&gt;parent-&gt;parent; &#125; else &#123; //RR型--&gt;左旋 if(fixNode == fixNode-&gt;parent-&gt;right) &#123; fixNode-&gt;parent-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; LeftRotate(rbTree, fixNode-&gt;parent-&gt;parent); &#125; //RL型--&gt;右旋+左旋 else &#123; fixNode-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; RightRotate(rbTree, fixNode-&gt;parent); LeftRotate(rbTree, fixNode); &#125; &#125; &#125; &#125; rbTree-&gt;root-&gt;color = BLACK; rbTree-&gt;root-&gt;parent = rbTree-&gt;nil; &#125; void RbTreeInsert(RbTree *rbTree, RbTreeNode *insertNode) &#123; //插入一个节点包括：寻找插入节点的位置；自平衡调整； RbTreeNode *x = rbTree-&gt;root; RbTreeNode *y = rbTree-&gt;nil; while(x != rbTree-&gt;nil) &#123; y = x; if(insertNode-&gt;key &lt; x-&gt;key) &#123; x = x-&gt;left; &#125; else if(insertNode-&gt;key &gt; x-&gt;key) &#123; x = x-&gt;right; &#125; else &#123; return; &#125; &#125; insertNode-&gt;parent = y; if(y == rbTree-&gt;nil) &#123; rbTree-&gt;root = insertNode; &#125; else if(insertNode-&gt;key &lt; y-&gt;key) &#123; y-&gt;left = insertNode; &#125; else &#123; y-&gt;right = insertNode; &#125; insertNode-&gt;left = rbTree-&gt;nil; insertNode-&gt;right = rbTree-&gt;nil; insertNode-&gt;color = RED; RbTreeInsertFixup(rbTree, insertNode); &#125; void RbTreeDelBlackNoleaf(RbTree *rbTree, RbTreeNode *delNode) &#123; RbTreeNode *delNodeSon; delNodeSon = (delNode-&gt;left == rbTree-&gt;nil)?(delNode-&gt;right):(delNode-&gt;left); if(unlikely((delNode-&gt;color != BLACK) || (delNodeSon-&gt;color != RED))) &#123; printf(&quot;[%d][%s]Not a rbTree!\\n&quot;, __LINE__, __FUNCTION__); &#125; if(delNode-&gt;parent == rbTree-&gt;nil) &#123; rbTree-&gt;root = delNode-&gt;left; &#125; else &#123; if(delNode == delNode-&gt;parent-&gt;left) &#123; delNode-&gt;parent-&gt;left = delNodeSon; &#125; else &#123; delNode-&gt;parent-&gt;right = delNodeSon; &#125; delNodeSon-&gt;parent = delNode-&gt;parent; delNodeSon-&gt;color = BLACK; &#125; return; &#125; void RbTreeDelRedLeaf(RbTree *rbTree, RbTreeNode *delNode) &#123; DelRbTreeNode(rbTree, delNode); &#125; void RbTreeDelBlackLeaf(RbTree *rbTree, RbTreeNode *delNode) &#123; RbTreeNode *delNodeBak = delNode; while(delNode-&gt;parent != rbTree-&gt;nil) &#123; RbTreeNode *broNode; if(delNode == delNode-&gt;parent-&gt;left) &#123; broNode = delNode-&gt;parent-&gt;right; if(broNode == rbTree-&gt;nil) break; if(broNode-&gt;color == RED) &#123; delNode-&gt;parent-&gt;color = RED; broNode-&gt;color = BLACK; LeftRotate(rbTree, delNode-&gt;parent); continue; &#125; else &#123; if((broNode-&gt;right != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;right-&gt;color == RED)) &#123; int tmpColor = delNode-&gt;parent-&gt;color; delNode-&gt;parent-&gt;color = broNode-&gt;color; broNode-&gt;color = tmpColor; broNode-&gt;right-&gt;color = BLACK; LeftRotate(rbTree, delNode-&gt;parent); break; &#125; else &#123; if((broNode-&gt;left != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;left-&gt;color == RED)) &#123; int tmpColor = delNode-&gt;parent-&gt;color; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;left-&gt;color = tmpColor; RightRotate(rbTree, broNode); LeftRotate(rbTree, delNode-&gt;parent); continue; &#125; else &#123; if(delNode-&gt;parent-&gt;color == RED) &#123; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;color = RED; break; &#125; else &#123; broNode-&gt;color = RED; delNode = delNode-&gt;parent; continue; &#125; &#125; &#125; &#125; &#125; else &#123; broNode = delNode-&gt;parent-&gt;left; if((broNode != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;color == RED)) &#123; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;color = BLACK; RightRotate(rbTree, delNode-&gt;parent); continue; &#125; else &#123; if((broNode != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;left != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;left-&gt;color == RED)) &#123; int tmpColor = delNode-&gt;parent-&gt;color; delNode-&gt;parent-&gt;color = broNode-&gt;color; broNode-&gt;color = tmpColor; broNode-&gt;left-&gt;color = BLACK; LeftRotate(rbTree, delNode-&gt;parent); break; &#125; else &#123; if((broNode != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;right != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;right-&gt;color == RED)) &#123; int tmpColor = delNode-&gt;parent-&gt;color; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;right-&gt;color = tmpColor; LeftRotate(rbTree, broNode); RightRotate(rbTree, delNode-&gt;parent); continue; &#125; else &#123; if(delNode-&gt;parent-&gt;color == RED) &#123; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;color = RED; break; &#125; else &#123; broNode-&gt;color = RED; delNode = delNode-&gt;parent; continue; &#125; &#125; &#125; &#125; &#125; &#125; DelRbTreeNode(rbTree, delNodeBak); &#125; void RbTreeDel(RbTree *rbTree, RbTreeNode *delNode) &#123; int tag = 0; while(tag != 2) &#123; if(delNode-&gt;left == rbTree-&gt;nil)//左子树为空 &#123; if(delNode-&gt;right == rbTree-&gt;nil)//右子树也为空 &#123; if(delNode-&gt;color == RED) &#123; RbTreeDelRedLeaf(rbTree, delNode); &#125; else if(delNode-&gt;color == BLACK) &#123; RbTreeDelBlackLeaf(rbTree, delNode); &#125; else &#123; printf(&quot;[%d][%s]ERR:node color err!\\n&quot;, __LINE__, __FUNCTION__); &#125; break; &#125; else//右子树不为空，此时仅有一种情况，即删除节点为黑色，右子节点为红色； &#123; RbTreeDelBlackNoleaf(rbTree, delNode); break; &#125; &#125; else//左子树不为空 &#123; if(delNode-&gt;right == rbTree-&gt;nil)//右子树为空 &#123; RbTreeDelBlackNoleaf(rbTree, delNode); break; &#125; else//左右子树都不为空 &#123; RbTreeNode *tempNode = delNode-&gt;right; while(tempNode-&gt;left != rbTree-&gt;nil) &#123; tempNode = tempNode-&gt;left; &#125; int tempKey = delNode-&gt;key; delNode-&gt;key = tempNode-&gt;key; delNode-&gt;value = tempNode-&gt;value; tempNode-&gt;key = tempKey; delNode = tempNode; tag++; &#125; &#125; &#125; return; &#125; RbTreeNode *RbTreeNodeCreate(int key, void* value) &#123; RbTreeNode *rbTreeNode = malloc(sizeof(RbTreeNode)); memset(rbTreeNode, 0 , sizeof(RbTreeNode)); rbTreeNode-&gt;key = key; rbTreeNode-&gt;value = value; return rbTreeNode; &#125; void PrintRbTreeNode(RbTreeNode *rbTreeNode) &#123; printf(&quot;Addr:%8x|key:%2d|color:%x|value:%s|left:%8x|right:%8x|parent:%8x\\n&quot;, (unsigned int)rbTreeNode, rbTreeNode-&gt;key, rbTreeNode-&gt;color, (char *)rbTreeNode-&gt;value, (unsigned int)rbTreeNode-&gt;left, (unsigned int)rbTreeNode-&gt;right, (unsigned int)rbTreeNode-&gt;parent); return; &#125; void TestDelBlackLeafNodeBroRed() &#123; RbTree *rbTree1 = malloc(sizeof(RbTree)); rbTree1-&gt;root = NULL; rbTree1-&gt;nil = NULL; RbTreeNode *rbTreeNode[NODENUM]; for(int i = 0; i &lt; NODENUM; ++i) &#123; rbTreeNode[i] = RbTreeNodeCreate(2*i, &quot;i&quot;); RbTreeInsert(rbTree1, rbTreeNode[i]); &#125; for(int i = 0; i &lt; NODENUM; ++i) &#123; PrintRbTreeNode(rbTreeNode[i]); &#125; printf(&quot;DELNODE\\n&quot;); RbTreeDel(rbTree1, rbTreeNode[12]); RbTreeDel(rbTree1, rbTreeNode[14]); RbTreeDel(rbTree1, rbTreeNode[13]); for(int i = 0; i &lt; NODENUM; ++i) &#123; PrintRbTreeNode(rbTreeNode[i]); &#125; for(int i = 0; i &lt; NODENUM; ++i) &#123; free(rbTreeNode[i]); rbTreeNode[i] = NULL; &#125; free(rbTree1); printf(&quot;===================[%s]===================\\n&quot;, __FUNCTION__); return; &#125; void TestDelBlackLeafNodeFarNephRed() &#123; RbTree *rbTree1 = malloc(sizeof(RbTree)); rbTree1-&gt;root = NULL; rbTree1-&gt;nil = NULL; RbTreeNode *rbTreeNode[NODENUM]; for(int i = 0; i &lt; NODENUM; ++i) &#123; rbTreeNode[i] = RbTreeNodeCreate(2*i, &quot;i&quot;); RbTreeInsert(rbTree1, rbTreeNode[i]); &#125; for(int i = 0; i &lt; NODENUM; ++i) &#123; PrintRbTreeNode(rbTreeNode[i]); &#125; printf(&quot;DELNODE\\n&quot;); RbTreeNode *rbTreeNode29 = RbTreeNodeCreate(29, &quot;j&quot;); RbTreeInsert(rbTree1, rbTreeNode29); RbTreeDel(rbTree1, rbTreeNode[12]); for(int i = 0; i &lt; NODENUM; ++i) &#123; PrintRbTreeNode(rbTreeNode[i]); &#125; PrintRbTreeNode(rbTreeNode29); for(int i = 0; i &lt; NODENUM; ++i) &#123; free(rbTreeNode[i]); rbTreeNode[i] = NULL; &#125; free(rbTreeNode29); free(rbTree1); printf(&quot;===================[%s]===================\\n&quot;, __FUNCTION__); return; &#125; void TestDelBlackLeafNodeNearNephRed() &#123; RbTree *rbTree1 = malloc(sizeof(RbTree)); rbTree1-&gt;root = NULL; rbTree1-&gt;nil = NULL; RbTreeNode *rbTreeNode[NODENUM]; for(int i = 0; i &lt; NODENUM; ++i) &#123; rbTreeNode[i] = RbTreeNodeCreate(2*i, &quot;i&quot;); RbTreeInsert(rbTree1, rbTreeNode[i]); &#125; for(int i = 0; i &lt; NODENUM; ++i) &#123; PrintRbTreeNode(rbTreeNode[i]); &#125; printf(&quot;DELNODE\\n&quot;); RbTreeNode *rbTreeNode27 = RbTreeNodeCreate(27, &quot;j&quot;); RbTreeInsert(rbTree1, rbTreeNode27); RbTreeDel(rbTree1, rbTreeNode[12]); for(int i = 0; i &lt; NODENUM; ++i) &#123; PrintRbTreeNode(rbTreeNode[i]); &#125; PrintRbTreeNode(rbTreeNode27); for(int i = 0; i &lt; NODENUM; ++i) &#123; free(rbTreeNode[i]); rbTreeNode[i] = NULL; &#125; free(rbTreeNode27); free(rbTree1); printf(&quot;===================[%s]===================\\n&quot;, __FUNCTION__); return; &#125; void TestDelBlackLeafNodeParentRed() &#123; RbTree *rbTree1 = malloc(sizeof(RbTree)); rbTree1-&gt;root = NULL; rbTree1-&gt;nil = NULL; RbTreeNode *rbTreeNode[NODENUM]; for(int i = 0; i &lt; NODENUM; ++i) &#123; rbTreeNode[i] = RbTreeNodeCreate(2*i, &quot;i&quot;); RbTreeInsert(rbTree1, rbTreeNode[i]); &#125; for(int i = 0; i &lt; NODENUM; ++i) &#123; PrintRbTreeNode(rbTreeNode[i]); &#125; printf(&quot;DELNODE\\n&quot;); RbTreeDel(rbTree1, rbTreeNode[12]); for(int i = 0; i &lt; NODENUM; ++i) &#123; PrintRbTreeNode(rbTreeNode[i]); &#125; for(int i = 0; i &lt; NODENUM; ++i) &#123; free(rbTreeNode[i]); rbTreeNode[i] = NULL; &#125; free(rbTree1); printf(&quot;===================[%s]===================\\n&quot;, __FUNCTION__); return; &#125; void TestDelBlackLeafNodeParentBlack() &#123; RbTree *rbTree1 = malloc(sizeof(RbTree)); rbTree1-&gt;root = NULL; rbTree1-&gt;nil = NULL; RbTreeNode *rbTreeNode[NODENUM]; for(int i = 0; i &lt; NODENUM; ++i) &#123; rbTreeNode[i] = RbTreeNodeCreate(2*i, &quot;i&quot;); RbTreeInsert(rbTree1, rbTreeNode[i]); &#125; for(int i = 0; i &lt; NODENUM; ++i) &#123; PrintRbTreeNode(rbTreeNode[i]); &#125; printf(&quot;DELNODE\\n&quot;); RbTreeDel(rbTree1, rbTreeNode[9]); for(int i = 0; i &lt; NODENUM; ++i) &#123; PrintRbTreeNode(rbTreeNode[i]); &#125; for(int i = 0; i &lt; NODENUM; ++i) &#123; free(rbTreeNode[i]); rbTreeNode[i] = NULL; &#125; free(rbTree1); printf(&quot;===================[%s]===================\\n&quot;, __FUNCTION__); return; &#125; int main() &#123; time_t begin = time(NULL); TestDelBlackLeafNodeBroRed(); TestDelBlackLeafNodeFarNephRed(); TestDelBlackLeafNodeNearNephRed(); TestDelBlackLeafNodeParentRed(); TestDelBlackLeafNodeParentBlack(); time_t end = time(NULL); gPrintSwitch = 1; printf(&quot;cost time:%ld\\n&quot;, end-begin); gPrintSwitch = 0; return 0; &#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"int型数据bit反转","slug":"int型数据bit反转","date":"2021-07-25T03:17:54.000Z","updated":"2021-10-17T06:29:57.424Z","comments":true,"path":"2021/07/25/int型数据bit反转/","link":"","permalink":"http://example.com/2021/07/25/int%E5%9E%8B%E6%95%B0%E6%8D%AEbit%E5%8F%8D%E8%BD%AC/","excerpt":"问题背景:计算int型数据bit位前后顺序反转后的数值，例如：input：22output：1744830464 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 18-Jul-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 25-Jul-2021 */#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define BYTELEN 8void TransformInt2Bit(unsigned int input, unsigned int* bitArr)&#123; for(int loop = 0; loop &lt; 32; loop++) &#123; bitArr[loop] = input % 2; input = (input&gt;&gt;1); &#125;&#125;void TransformBit2Int(unsigned int* output, unsigned int *bitArr)&#123; for(int loop = 0; loop &lt; 32; loop++) &#123; *output += bitArr[loop] * pow(2, loop); &#125;&#125;void ReverseArr(unsigned int *arr, unsigned int size)&#123; int temp = 0; for(int loop = 0; loop &lt; (size/2); loop++) &#123; temp = arr[loop]; arr[loop] = arr[size-1-loop]; arr[size-1-loop] = temp; &#125;&#125;int main()&#123; unsigned int input; scanf(&quot;%d&quot;, &amp;input); unsigned bitArr[BYTELEN*sizeof(input)]; TransformInt2Bit(input, bitArr); ReverseArr(bitArr, sizeof(arr)/sizeof(int)); unsigned int output = 0; TransformBit2Int(&amp;output, bitArr); printf(&quot;%u\\n&quot;, output); return 0;&#125;","text":"问题背景:计算int型数据bit位前后顺序反转后的数值，例如：input：22output：1744830464 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 18-Jul-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 25-Jul-2021 */#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define BYTELEN 8void TransformInt2Bit(unsigned int input, unsigned int* bitArr)&#123; for(int loop = 0; loop &lt; 32; loop++) &#123; bitArr[loop] = input % 2; input = (input&gt;&gt;1); &#125;&#125;void TransformBit2Int(unsigned int* output, unsigned int *bitArr)&#123; for(int loop = 0; loop &lt; 32; loop++) &#123; *output += bitArr[loop] * pow(2, loop); &#125;&#125;void ReverseArr(unsigned int *arr, unsigned int size)&#123; int temp = 0; for(int loop = 0; loop &lt; (size/2); loop++) &#123; temp = arr[loop]; arr[loop] = arr[size-1-loop]; arr[size-1-loop] = temp; &#125;&#125;int main()&#123; unsigned int input; scanf(&quot;%d&quot;, &amp;input); unsigned bitArr[BYTELEN*sizeof(input)]; TransformInt2Bit(input, bitArr); ReverseArr(bitArr, sizeof(arr)/sizeof(int)); unsigned int output = 0; TransformBit2Int(&amp;output, bitArr); printf(&quot;%u\\n&quot;, output); return 0;&#125;","categories":[{"name":"习题","slug":"习题","permalink":"http://example.com/categories/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}]},{"title":"C 解一元一次方程","slug":"C解一元一次方程","date":"2021-07-19T18:43:58.000Z","updated":"2021-10-17T06:30:11.369Z","comments":true,"path":"2021/07/20/C解一元一次方程/","link":"","permalink":"http://example.com/2021/07/20/C%E8%A7%A3%E4%B8%80%E5%85%83%E4%B8%80%E6%AC%A1%E6%96%B9%E7%A8%8B/","excerpt":"问题背景：实现一元一次方程的计算，例如：input：3a+3=9output:a=2 note:给出的一元一次方程中没有括号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 20-Jul-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 25-Jul-2021 *//*//实现解一元一次方程//step1 接收输入，并转换成需要的数据格式//step2 算法实现//step3 输出结果，并清理程序资源1 接收的输入格式为一行字符串，选择将其存储在数组中 声明需要的数组资源，类型大小； 使用getc函数接收输入并存储在数组中； 当接收到‘\\n’时表示结束； 将存储在数组中的输入打印出来检测是否正确；2 算法思路就是将一元一次表达式转换为AX+B=0的形式。然后直接计算X=-(B/A)即可； 因此需要遍历表达式中的元素进行区分合并同类项，根据项的特点可以将数组中存储的内容分为三类，分别是符号、数字和字母；实现时根据ASCII码进行区分； 此处设计两个栈，A栈和B栈，分别存储计算系数A和B时的元素，将数组中的元素从右到左遍历， 1 若元素是字母则表示该项为AX，即需要把当前栈指向A栈，否则指向B栈 2 若元素是数字，则直接存入当前栈 3 若元素是符号，则更新符号变量，并计算当前栈内元素组成的数字大小，累加到系数A或B，然后清空当前栈并释放当前栈*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#define POPNUM_IS_WORD(popNum) (Int2Char(popNum) &gt;= &#x27;a&#x27;) &amp;&amp; (Int2Char(popNum) &lt;= &#x27;z&#x27;)#define POPNUM_IS_NUM(popNum) (Int2Char(popNum) &lt;= &#x27;9&#x27;) &amp;&amp; (Int2Char(popNum) &gt;= &#x27;0&#x27;)#define POPNUM_IS_EQUAL(popNum) (Int2Char(popNum) == &#x27;=&#x27;)#define POPNUM_IS_PLUS(popNum) (Int2Char(popNum) == &#x27;+&#x27;)#define POPNUM_IS_SUBSTRACT(popNum) (Int2Char(popNum) == &#x27;-&#x27;)int StoreInput(char *arr, int size)&#123; for(int loop = 0; loop &lt; size; loop++) &#123; scanf(&quot;%c&quot;, arr+loop); if(*(arr+loop) == &#x27;\\n&#x27;) &#123; return loop; &#125; &#125; printf(&quot;The input is too long!\\n&quot;); return 0;&#125;typedef struct node&#123; int num; struct node* next;&#125;node;void NodeFree(node* head)&#123; node* tNode; while(head-&gt;next != NULL) &#123; tNode = head-&gt;next; free(head); head = tNode; &#125; return;&#125;node* GetCurNode(node* head)&#123; node* temp = head; while(temp-&gt;next != NULL) &#123; temp = temp-&gt;next; &#125; return temp;&#125;void NodePush(node* head, int num)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return; &#125; node* curNode = GetCurNode(head); node* nextNode = (node*)malloc(sizeof(node)); nextNode-&gt;num = num; nextNode-&gt;next = NULL; curNode-&gt;next = nextNode;&#125;int NodePop(node* head)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return -1; &#125; int popNum = 0; node* prevNode = head; if(prevNode-&gt;next == NULL) &#123; popNum = prevNode-&gt;num; //printf(&quot;%d\\n&quot;, popNum); free(prevNode); return popNum; &#125; node* relNode = prevNode-&gt;next; while(relNode-&gt;next != NULL) &#123; prevNode = prevNode-&gt;next; relNode = prevNode-&gt;next; &#125; popNum = relNode-&gt;num; free(relNode); prevNode-&gt;next = NULL; return popNum;;&#125;void NodePrint(node* head)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return; &#125; node* curNode = head; while(curNode-&gt;next != NULL) &#123; curNode = curNode-&gt;next; &#125;&#125;int char2Int(char c)&#123; return (int)(c-&#x27;0&#x27;);&#125;char Int2Char(int num)&#123; return (char)(num+&#x27;0&#x27;);&#125;int GetCurStackValue(int curStackLen, node* curStack)&#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; return temp;&#125;void UpdateCoef(node* curStack, node* stackA, node* stackB, double* coefA, double* coefB, int temp, int coefSym)&#123; if(curStack == stackA) &#123; if(temp != 0) *coefA += coefSym * temp; else *coefA += coefSym; //printf(&quot;coefA:%f\\n&quot;, *coefA); &#125; if(curStack == stackB) &#123; *coefB += coefSym * temp; //printf(&quot;coefB:%f\\n&quot;, *coefB); &#125;&#125;void UpdateCoefFirstTerm(int loop, node* curStack, node* stackA, node* stackB, double* coefA, double* coefB, int coefSym, int curStackLen)&#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; if(curStack == stackA) &#123; *coefA += (coefSym) * temp; &#125; if(curStack == stackB) &#123; *coefB += (coefSym) * temp; &#125; NodeFree(curStack); curStack = stackB; curStackLen = 0;&#125;void calcCoef(node* head, int pos, double* coefA, double* coefB, char* unKownNum)&#123; node stackA, stackB; stackA.num = 0; stackA.next = NULL; stackB.num = 0; stackB.next = NULL; node* curStack = &amp;stackB; char popNum; int curStackLen = 0, coefSym = -1; for(int loop = pos; loop &gt; 0; loop--) &#123; popNum = (char)NodePop(head); if(POPNUM_IS_WORD(popNum)) &#123; curStack = &amp;stackA; *unKownNum = Int2Char(popNum); if(loop == 1) *coefA += 1; continue; &#125; if(POPNUM_IS_NUM(popNum)) &#123; NodePush(curStack, (int)popNum); curStackLen++; if(loop == 1) &#123; UpdateCoefFirstTerm(loop, curStack, &amp;stackA, &amp;stackB, coefA, coefB, coefSym, curStackLen); &#125; continue; &#125; if(POPNUM_IS_EQUAL(popNum)) &#123; int temp = GetCurStackValue(curStackLen, curStack); //printf(&quot;=|temp:%d\\n&quot;, temp); UpdateCoef(curStack, &amp;stackA, &amp;stackB, coefA, coefB, temp, coefSym); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; coefSym = 1; &#125; if(POPNUM_IS_SUBSTRACT(popNum)) &#123; int temp = GetCurStackValue(curStackLen, curStack); coefSym = coefSym * (-1); UpdateCoef(curStack, &amp;stackA, &amp;stackB, coefA, coefB, temp, coefSym); //printf(&quot;coefA:%f\\ncoefB:%f\\n&quot;, *coefA, *coefB); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; if(POPNUM_IS_PLUS(popNum)) &#123; int temp = GetCurStackValue(curStackLen, curStack); UpdateCoef(curStack, &amp;stackA, &amp;stackB, coefA, coefB, temp, coefSym); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; &#125;&#125;int main()&#123; char arr[30]; int pos; pos = StoreInput(arr, 30); node *head = (node*)malloc(sizeof(node)); head-&gt;num = 0; head-&gt;next = NULL; for(int loop = 0; loop &lt; pos; loop++) &#123; NodePush(head, char2Int(*(arr+loop))); &#125; double coefA = 0, coefB = 0; char unKownNum; calcCoef(head, pos, &amp;coefA, &amp;coefB, &amp;unKownNum); printf(&quot;%c=%.3f\\n&quot;, unKownNum, (-coefB/coefA)); NodeFree(head); free(head); return 0;&#125;","text":"问题背景：实现一元一次方程的计算，例如：input：3a+3=9output:a=2 note:给出的一元一次方程中没有括号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 20-Jul-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 25-Jul-2021 *//*//实现解一元一次方程//step1 接收输入，并转换成需要的数据格式//step2 算法实现//step3 输出结果，并清理程序资源1 接收的输入格式为一行字符串，选择将其存储在数组中 声明需要的数组资源，类型大小； 使用getc函数接收输入并存储在数组中； 当接收到‘\\n’时表示结束； 将存储在数组中的输入打印出来检测是否正确；2 算法思路就是将一元一次表达式转换为AX+B=0的形式。然后直接计算X=-(B/A)即可； 因此需要遍历表达式中的元素进行区分合并同类项，根据项的特点可以将数组中存储的内容分为三类，分别是符号、数字和字母；实现时根据ASCII码进行区分； 此处设计两个栈，A栈和B栈，分别存储计算系数A和B时的元素，将数组中的元素从右到左遍历， 1 若元素是字母则表示该项为AX，即需要把当前栈指向A栈，否则指向B栈 2 若元素是数字，则直接存入当前栈 3 若元素是符号，则更新符号变量，并计算当前栈内元素组成的数字大小，累加到系数A或B，然后清空当前栈并释放当前栈*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#define POPNUM_IS_WORD(popNum) (Int2Char(popNum) &gt;= &#x27;a&#x27;) &amp;&amp; (Int2Char(popNum) &lt;= &#x27;z&#x27;)#define POPNUM_IS_NUM(popNum) (Int2Char(popNum) &lt;= &#x27;9&#x27;) &amp;&amp; (Int2Char(popNum) &gt;= &#x27;0&#x27;)#define POPNUM_IS_EQUAL(popNum) (Int2Char(popNum) == &#x27;=&#x27;)#define POPNUM_IS_PLUS(popNum) (Int2Char(popNum) == &#x27;+&#x27;)#define POPNUM_IS_SUBSTRACT(popNum) (Int2Char(popNum) == &#x27;-&#x27;)int StoreInput(char *arr, int size)&#123; for(int loop = 0; loop &lt; size; loop++) &#123; scanf(&quot;%c&quot;, arr+loop); if(*(arr+loop) == &#x27;\\n&#x27;) &#123; return loop; &#125; &#125; printf(&quot;The input is too long!\\n&quot;); return 0;&#125;typedef struct node&#123; int num; struct node* next;&#125;node;void NodeFree(node* head)&#123; node* tNode; while(head-&gt;next != NULL) &#123; tNode = head-&gt;next; free(head); head = tNode; &#125; return;&#125;node* GetCurNode(node* head)&#123; node* temp = head; while(temp-&gt;next != NULL) &#123; temp = temp-&gt;next; &#125; return temp;&#125;void NodePush(node* head, int num)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return; &#125; node* curNode = GetCurNode(head); node* nextNode = (node*)malloc(sizeof(node)); nextNode-&gt;num = num; nextNode-&gt;next = NULL; curNode-&gt;next = nextNode;&#125;int NodePop(node* head)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return -1; &#125; int popNum = 0; node* prevNode = head; if(prevNode-&gt;next == NULL) &#123; popNum = prevNode-&gt;num; //printf(&quot;%d\\n&quot;, popNum); free(prevNode); return popNum; &#125; node* relNode = prevNode-&gt;next; while(relNode-&gt;next != NULL) &#123; prevNode = prevNode-&gt;next; relNode = prevNode-&gt;next; &#125; popNum = relNode-&gt;num; free(relNode); prevNode-&gt;next = NULL; return popNum;;&#125;void NodePrint(node* head)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return; &#125; node* curNode = head; while(curNode-&gt;next != NULL) &#123; curNode = curNode-&gt;next; &#125;&#125;int char2Int(char c)&#123; return (int)(c-&#x27;0&#x27;);&#125;char Int2Char(int num)&#123; return (char)(num+&#x27;0&#x27;);&#125;int GetCurStackValue(int curStackLen, node* curStack)&#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; return temp;&#125;void UpdateCoef(node* curStack, node* stackA, node* stackB, double* coefA, double* coefB, int temp, int coefSym)&#123; if(curStack == stackA) &#123; if(temp != 0) *coefA += coefSym * temp; else *coefA += coefSym; //printf(&quot;coefA:%f\\n&quot;, *coefA); &#125; if(curStack == stackB) &#123; *coefB += coefSym * temp; //printf(&quot;coefB:%f\\n&quot;, *coefB); &#125;&#125;void UpdateCoefFirstTerm(int loop, node* curStack, node* stackA, node* stackB, double* coefA, double* coefB, int coefSym, int curStackLen)&#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; if(curStack == stackA) &#123; *coefA += (coefSym) * temp; &#125; if(curStack == stackB) &#123; *coefB += (coefSym) * temp; &#125; NodeFree(curStack); curStack = stackB; curStackLen = 0;&#125;void calcCoef(node* head, int pos, double* coefA, double* coefB, char* unKownNum)&#123; node stackA, stackB; stackA.num = 0; stackA.next = NULL; stackB.num = 0; stackB.next = NULL; node* curStack = &amp;stackB; char popNum; int curStackLen = 0, coefSym = -1; for(int loop = pos; loop &gt; 0; loop--) &#123; popNum = (char)NodePop(head); if(POPNUM_IS_WORD(popNum)) &#123; curStack = &amp;stackA; *unKownNum = Int2Char(popNum); if(loop == 1) *coefA += 1; continue; &#125; if(POPNUM_IS_NUM(popNum)) &#123; NodePush(curStack, (int)popNum); curStackLen++; if(loop == 1) &#123; UpdateCoefFirstTerm(loop, curStack, &amp;stackA, &amp;stackB, coefA, coefB, coefSym, curStackLen); &#125; continue; &#125; if(POPNUM_IS_EQUAL(popNum)) &#123; int temp = GetCurStackValue(curStackLen, curStack); //printf(&quot;=|temp:%d\\n&quot;, temp); UpdateCoef(curStack, &amp;stackA, &amp;stackB, coefA, coefB, temp, coefSym); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; coefSym = 1; &#125; if(POPNUM_IS_SUBSTRACT(popNum)) &#123; int temp = GetCurStackValue(curStackLen, curStack); coefSym = coefSym * (-1); UpdateCoef(curStack, &amp;stackA, &amp;stackB, coefA, coefB, temp, coefSym); //printf(&quot;coefA:%f\\ncoefB:%f\\n&quot;, *coefA, *coefB); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; if(POPNUM_IS_PLUS(popNum)) &#123; int temp = GetCurStackValue(curStackLen, curStack); UpdateCoef(curStack, &amp;stackA, &amp;stackB, coefA, coefB, temp, coefSym); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; &#125;&#125;int main()&#123; char arr[30]; int pos; pos = StoreInput(arr, 30); node *head = (node*)malloc(sizeof(node)); head-&gt;num = 0; head-&gt;next = NULL; for(int loop = 0; loop &lt; pos; loop++) &#123; NodePush(head, char2Int(*(arr+loop))); &#125; double coefA = 0, coefB = 0; char unKownNum; calcCoef(head, pos, &amp;coefA, &amp;coefB, &amp;unKownNum); printf(&quot;%c=%.3f\\n&quot;, unKownNum, (-coefB/coefA)); NodeFree(head); free(head); return 0;&#125;","categories":[{"name":"习题","slug":"习题","permalink":"http://example.com/categories/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}]},{"title":"手把手教你写Makefile和CMakelists.txt","slug":"Makefile及CMake教程","date":"2021-06-25T15:22:55.000Z","updated":"2021-06-29T13:42:53.367Z","comments":true,"path":"2021/06/25/Makefile及CMake教程/","link":"","permalink":"http://example.com/2021/06/25/Makefile%E5%8F%8ACMake%E6%95%99%E7%A8%8B/","excerpt":"入职后开始接触了Linux环境下的代码，而且是一个代码量10W+的巨型工程，刚面对这样打的项目时总是对其中重重的文件目录感到惊讶，这么多的文件是怎么变成最后的可执行文件的？ 之前在学校或者个人学习的时候写的代码都是比较简单的，一个目录下若干个c文件，编译时直接使用gcc工具一步执行gcc main.c -o main就完事了，但是面对这种多目录多源文件的项目如果还使用这种方法的话明显生产效率是极低的。由于不同的项目在进行编译时都使用相同的编译指令，只是路径和文件名不同，所以自然想到应该可以编写脚本实现编译自动化，经过学习发现原来有一种专门的脚本语言用来解决这件事，就是今天学习的内容Makefile和CMakelists.txt。 什么是Makefile首先说下Makefile，Makefile就是包含编译指令的一个脚本，Makefile需要和make搭配使用，make是Linux平台下的一个工具，通过它可以执行Makefile中的编译指令以完成工程的编译。make和Makefile的关系可以用bash和shell脚本做类比，脚本中按照脚本的规定语法写好了一些指令，然后通过对应的执行命令将脚本中的一系列指令执行完成。 接下来我们就来看下书写Makefile脚本的语法规则吧，首先我们都知道生成一个可执行文件需要有源文件，而源文件多数也都需要依赖文件，例如头文件等，Makefile中也必须遵循这样的原则。 makefile的语法规则之一就是：(以C语言项目为例，使用GCC工具，如果是C++项目则使用G++工具) targetFile:sourceFilegcc -[E][S][C][ ] sourceFile -o targetFile # gcc -E 表示只进行预编译，得到的目标文件为后缀为i的预编译文件（预编译执行的操作包括头展开，宏替换以及条件编译优化） # gcc -S 表示进行预编译和汇编，得到后缀为s的汇编文件（汇编将预编译的代码转换为汇编代码）","text":"入职后开始接触了Linux环境下的代码，而且是一个代码量10W+的巨型工程，刚面对这样打的项目时总是对其中重重的文件目录感到惊讶，这么多的文件是怎么变成最后的可执行文件的？ 之前在学校或者个人学习的时候写的代码都是比较简单的，一个目录下若干个c文件，编译时直接使用gcc工具一步执行gcc main.c -o main就完事了，但是面对这种多目录多源文件的项目如果还使用这种方法的话明显生产效率是极低的。由于不同的项目在进行编译时都使用相同的编译指令，只是路径和文件名不同，所以自然想到应该可以编写脚本实现编译自动化，经过学习发现原来有一种专门的脚本语言用来解决这件事，就是今天学习的内容Makefile和CMakelists.txt。 什么是Makefile首先说下Makefile，Makefile就是包含编译指令的一个脚本，Makefile需要和make搭配使用，make是Linux平台下的一个工具，通过它可以执行Makefile中的编译指令以完成工程的编译。make和Makefile的关系可以用bash和shell脚本做类比，脚本中按照脚本的规定语法写好了一些指令，然后通过对应的执行命令将脚本中的一系列指令执行完成。 接下来我们就来看下书写Makefile脚本的语法规则吧，首先我们都知道生成一个可执行文件需要有源文件，而源文件多数也都需要依赖文件，例如头文件等，Makefile中也必须遵循这样的原则。 makefile的语法规则之一就是：(以C语言项目为例，使用GCC工具，如果是C++项目则使用G++工具) targetFile:sourceFilegcc -[E][S][C][ ] sourceFile -o targetFile # gcc -E 表示只进行预编译，得到的目标文件为后缀为i的预编译文件（预编译执行的操作包括头展开，宏替换以及条件编译优化） # gcc -S 表示进行预编译和汇编，得到后缀为s的汇编文件（汇编将预编译的代码转换为汇编代码） # gcc -c 表示进行预编译、汇编和编译，得到后缀为o的二进制文件（编译将汇编代码转换为二进制机器语言） # gcc不带参数表示直接进行预编译、汇编、编译和链接，得到可执行文件 其中第一行定义了目标文件和源文件，中间用冒号隔开，第二行先用TAB键置空位，然后给出了具体的实现指令。 该命令只有在目标文件不存在，或目标比依赖的文件更旧，才会被执行。 当我们的工程中在同一目录下出现了多个C源文件时，则需重复上面两行指令依次生成.o文件最后链接成可执行文件。那么为了减少这种重复度极高的代码的书写，makefile语法中提供了一种设置替换的方式，可以将所有的同类型文件用一个变量来表示。 OBJ=a.o b.o c.o TAR=main 这样Makefile中所有出现a.o b.o c.o的地方就都可以用$(OBJ)来代替，所有出现main的地方都可以用$(TAR)表示，$(变量名)为变量的使用方式。 另外还可以用+=进行追加使变量可以适用于不同的场景。:=则表示恒等于，使用恒等于设置的变量就不能在进行追加了。 除此以外，还有一些固定变量，**%.c表示任意的.c文件，%.o表示任意的.o文件， .c表示所有的.c文件，.o表示所有的.o文件，$@表示所有的目标文件，$^表示所有的依赖文件，$&lt;表示所有依赖文件的第一个**。 通过这些变量使得我们的Makefile大大精简，同时还增强了Makefile在不同工程下的适用性。 最后在Makefile文件中还会集成一些和编译无关的操作我们希望在进行编译时或之前或之后同时进行的，例如编译之前先清除遗留的中间文件而重新生成覆盖，Makefile同样提供了一种伪目标的方式来实现。 .PHONY:clear clear: rm -rf main.o main .PHONY后面的target（即冒号之前的文件）表示的也是一个伪造的target, 而不是真实存在的文件target 总结一下，Makefile的编写其实就包括三步，第一步，指定目标文件和依赖文件；第二步，给出从依赖文件到目标文件的实现指令；第三步，进行变量替换； 华丽的分割线 CMakelists.txt又是什么东西?因为不同平台下的Makefile书写规则是不一样的，Makefile只适用于类UNIX系统下的编译，如果是在Windows环境下则需要重新编写Makefile。cmake就是为了解决跨平台编译的问题，使用cmake工具，可以自动生成适应平台的Makefile。 同样的，在单目录的场景下，CMakelists.txt的语法如下 CMAKE_MINIMUM_REQUIRED(3.10) PROJECT(main) AUX_SOURCE_DIR(./ DIR_SRC) ADD_EXECUTABLE(main ${DIR_SRC}) 只需要三行代码，第一行指定支持的cmake最低版本；第二行给工程命名；第三行将目录下所有源文件打包成变量，第四行生成可执行文件； 如果是多目录下，比如一个库文件目录和一个源文件目录的话，则需要在每个目录下面都编写一个CMakeLists.txt，一共三个，分别是源文件目录，库文件目录和根目录 其中源文件目录src下的CMakeListx.txt内容如下 AUX_SOURCE_DIRECTORY(./ DIR_SRC) ADD_EXECUTABLE(main ${DIR_SRC}) TARGET_LINK_LIBRARIES(main mylib) 库文件目录mylib下面的CMakeLists.txt内容如下 AUX_SOURCE_DIRECTORY(./ DIR_LIB) ADD_LIBRARY(mylib ${DIR_LIB}) 根目录下的CMakeLists.txt内容如下 CMAKE_MINIMUM_REQUIRED(3.10) PROJECT(main) ADD_SUBDIRECTORY(./src) ADD_SUBDIRECTORY(./mylib) 这是库目录和源文件目录分离的场景，如果说只有一个源文件没必要新建一个源文件目录即不存在源文件目录的情况下，库目录下的CMakeLists.txt不变，根目录下的CMakeLists.txt内容如下 CMAKE_MINIMUM_REQUIRED(3.10) PROJECT(main) ADD_SUBDIRECTORY(./mylib) AUX_SOURCE_DIRECTORY(./ DIR_SRC) ADD_EXECUTABLE(main ${DIR_SRC}) TARGET_LINK_LIBRARIES(main mylib) 实际上就是把原来根目录和源文件目录下的CMakeLists.txt合并了 以上是自己学习CMake的一点学习记录，总结下来发现也完全不难，只需要理解两个场景单目录和多目录下的编写方式就可以了，关键的语法不超过10行，CMake的知识点还有很多，具体详情可以在网上搜索。总之，CMake可以让我们不用去编写复杂的Makefile，并且跨平台，是个非常强大并值得一学的工具。 如果有写的不对的地方，希望能留言指正，谢谢阅读。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"编译技术","slug":"编译技术","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"}]}],"categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"习题","permalink":"http://example.com/categories/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"编译技术","slug":"编译技术","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"}]}