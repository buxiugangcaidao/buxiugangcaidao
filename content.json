{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-06-27T06:02:15.000Z","updated":"2021-06-27T06:44:30.897Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"红黑树","slug":"红黑树","date":"2021-10-17T12:14:51.000Z","updated":"2021-10-26T16:42:00.423Z","comments":true,"path":"2021/10/17/红黑树/","link":"","permalink":"http://example.com/2021/10/17/%E7%BA%A2%E9%BB%91%E6%A0%91/","excerpt":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 17-Oct-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 27-Oct-2021 */#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;//#include&lt;thread.h&gt;#define likely(x) __builtin_expect(!!(x), 1) //gcc内置函数, 帮助编译器分支优化#define unlikely(x) __builtin_expect(!!(x), 0)#define RED 1#define BLACK 2typedef struct RbTreeNode&#123; struct RbTreeNode *left; struct RbTreeNode *right; struct RbTreeNode *parent; unsigned char color; int key; void *value;&#125;RbTreeNode;typedef struct RbTree&#123; RbTreeNode *root; RbTreeNode *nil;&#125;RbTree;RbTreeNode* AllocRbTreeNode()&#123; RbTreeNode *rbTreeNode = NULL; rbTreeNode = malloc(sizeof(RbTreeNode)); if(rbTreeNode == NULL) return NULL; memset(rbTreeNode, 0, sizeof(RbTreeNode)); return rbTreeNode;&#125;void DelRbTreeNode(RbTree *rbTree, RbTreeNode *delNode)&#123; if(delNode-&gt;parent == rbTree-&gt;nil) free(delNode); if(delNode == delNode-&gt;parent-&gt;left) &#123; delNode-&gt;parent-&gt;left = rbTree-&gt;nil; &#125; else &#123; delNode-&gt;parent-&gt;right = rbTree-&gt;nil; &#125; free(delNode); return;&#125;void LeftRotate(RbTree *rbTree, RbTreeNode *rotNode)&#123; RbTreeNode *rightNode = rotNode-&gt;right; rotNode-&gt;right = rightNode-&gt;left; if(rightNode-&gt;left != rbTree-&gt;nil) &#123; rightNode-&gt;left-&gt;parent = rotNode; &#125; if(rotNode-&gt;parent == rbTree-&gt;nil) &#123; rbTree-&gt;root = rightNode; &#125; else if(rotNode == rotNode-&gt;parent-&gt;left) &#123; rotNode-&gt;parent-&gt;left = rightNode; rightNode-&gt;parent = rotNode-&gt;parent; &#125; else &#123; rotNode-&gt;parent-&gt;right = rightNode; rightNode-&gt;parent = rotNode-&gt;parent; &#125; rightNode-&gt;left = rotNode; rotNode-&gt;parent = rightNode; return;&#125;void RightRotate(RbTree *rbTree, RbTreeNode *rotNode)&#123; RbTreeNode *leftNode = rotNode-&gt;left; rotNode-&gt;left = leftNode-&gt;right; if(leftNode-&gt;right != rbTree-&gt;nil) &#123; leftNode-&gt;right-&gt;parent = rotNode; &#125; if(rotNode-&gt;parent == rbTree-&gt;nil) &#123; rbTree-&gt;root = leftNode; &#125; else if(rotNode == rotNode-&gt;parent-&gt;left) &#123; rotNode-&gt;parent-&gt;left = leftNode; leftNode-&gt;parent = rotNode-&gt;parent; &#125; else &#123; rotNode-&gt;parent-&gt;right = leftNode; leftNode-&gt;parent = rotNode-&gt;parent; &#125; leftNode-&gt;right = rotNode; rotNode-&gt;parent = leftNode;&#125;void RbTreeInsertFixup(RbTree *rbTree, RbTreeNode *fixNode)&#123; while((fixNode-&gt;parent != rbTree-&gt;nil) &amp;&amp; (fixNode-&gt;parent-&gt;color == RED)) &#123; if(fixNode-&gt;parent == fixNode-&gt;parent-&gt;parent-&gt;left) &#123; RbTreeNode *y = fixNode-&gt;parent-&gt;parent-&gt;right; if((y != rbTree-&gt;nil) &amp;&amp; (y-&gt;color == RED)) &#123; fixNode-&gt;parent-&gt;color = BLACK; y-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; fixNode = fixNode-&gt;parent-&gt;parent; &#125; else &#123; // LL型--&gt;右旋 if(fixNode == fixNode-&gt;parent-&gt;left) &#123; fixNode-&gt;parent-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; RightRotate(rbTree, fixNode-&gt;parent-&gt;parent); &#125; //LR型--左旋+右旋 else &#123; fixNode-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; LeftRotate(rbTree, fixNode-&gt;parent); RightRotate(rbTree, fixNode-&gt;parent); &#125; &#125; &#125; else &#123; RbTreeNode *y = fixNode-&gt;parent-&gt;parent-&gt;left; if((y != rbTree-&gt;nil) &amp;&amp; (y-&gt;color == RED)) &#123; fixNode-&gt;parent-&gt;color = BLACK; y-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; fixNode = fixNode-&gt;parent-&gt;parent; &#125; else &#123; //RR型--&gt;左旋 if(fixNode == fixNode-&gt;parent-&gt;right) &#123; fixNode-&gt;parent-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; LeftRotate(rbTree, fixNode-&gt;parent-&gt;parent); &#125; //RL型--&gt;右旋+左旋 else &#123; fixNode-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; RightRotate(rbTree, fixNode-&gt;parent); LeftRotate(rbTree, fixNode); &#125; &#125; &#125; &#125; rbTree-&gt;root-&gt;color = BLACK; rbTree-&gt;root-&gt;parent = rbTree-&gt;nil;&#125;void RbTreeInsert(RbTree *rbTree, RbTreeNode *insertNode)&#123; //插入一个节点包括：寻找插入节点的位置；自平衡调整； RbTreeNode *x = rbTree-&gt;root; RbTreeNode *y = rbTree-&gt;nil; while(x != rbTree-&gt;nil) &#123; y = x; if(insertNode-&gt;key &lt; x-&gt;key) &#123; x = x-&gt;left; &#125; else if(insertNode-&gt;key &gt; x-&gt;key) &#123; x = x-&gt;right; &#125; else &#123; return; &#125; &#125; insertNode-&gt;parent = y; if(y == rbTree-&gt;nil) &#123; rbTree-&gt;root = insertNode; &#125; else if(insertNode-&gt;key &lt; y-&gt;key) &#123; y-&gt;left = insertNode; &#125; else &#123; y-&gt;right = insertNode; &#125; insertNode-&gt;left = rbTree-&gt;nil; insertNode-&gt;right = rbTree-&gt;nil; insertNode-&gt;color = RED; RbTreeInsertFixup(rbTree, insertNode);&#125;void RbTreeDelBlackNoleaf(RbTree *rbTree, RbTreeNode *delNode)&#123; RbTreeNode *delNodeSon; delNodeSon = (delNode-&gt;left == rbTree-&gt;nil)?(delNode-&gt;right):(delNode-&gt;left); if(unlikely((delNode-&gt;color != BLACK) || (delNodeSon-&gt;color != RED))) &#123; printf(&quot;[%d][%s]Not a rbTree!\\n&quot;, __LINE__, __FUNCTION__); &#125; if(delNode-&gt;parent == rbTree-&gt;nil) &#123; rbTree-&gt;root = delNode-&gt;left; &#125; else &#123; if(delNode == delNode-&gt;parent-&gt;left) &#123; delNode-&gt;parent-&gt;left = delNodeSon; &#125; else &#123; delNode-&gt;parent-&gt;right = delNodeSon; &#125; delNodeSon-&gt;parent = delNode-&gt;parent; delNodeSon-&gt;color = BLACK; free(delNode); &#125; return;&#125;void RbTreeDelRedLeaf(RbTree *rbTree, RbTreeNode *delNode)&#123; DelRbTreeNode(rbTree, delNode);&#125;void RbTreeDelBlackLeaf(RbTree *rbTree, RbTreeNode *delNode)&#123; while(delNode-&gt;parent != rbTree-&gt;nil) &#123; RbTreeNode *broNode; if(delNode == delNode-&gt;parent-&gt;left) &#123; broNode = delNode-&gt;parent-&gt;right; if(broNode-&gt;color == RED) &#123; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;color = BLACK; LeftRotate(rbTree, delNode-&gt;parent); continue; &#125; else &#123; if((broNode-&gt;right != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;right-&gt;color == RED)) &#123; int tmpColor = delNode-&gt;parent-&gt;color; delNode-&gt;parent-&gt;color = broNode-&gt;color; broNode-&gt;color = tmpColor; broNode-&gt;right-&gt;color = BLACK; LeftRotate(rbTree, delNode-&gt;parent); break; &#125; else &#123; if((broNode-&gt;left != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;left-&gt;color == RED)) &#123; int tmpColor = delNode-&gt;parent-&gt;color; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;left-&gt;color = tmpColor; RightRotate(rbTree, broNode); LeftRotate(rbTree, delNode-&gt;parent); continue; &#125; else &#123; if(delNode-&gt;parent-&gt;color == RED) &#123; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;color = RED; break; &#125; else &#123; broNode-&gt;color = RED; delNode = delNode-&gt;parent; continue; &#125; &#125; &#125; &#125; &#125; else &#123; broNode = delNode-&gt;parent-&gt;left; if(broNode-&gt;color == RED) &#123; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;color = BLACK; RightRotate(rbTree, delNode-&gt;parent); continue; &#125; else &#123; if((broNode-&gt;left != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;left-&gt;color == RED)) &#123; int tmpColor = delNode-&gt;parent-&gt;color; delNode-&gt;parent-&gt;color = broNode-&gt;color; broNode-&gt;color = tmpColor; broNode-&gt;left-&gt;color = BLACK; LeftRotate(rbTree, delNode-&gt;parent); break; &#125; else &#123; if((broNode-&gt;right != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;right-&gt;color == RED)) &#123; int tmpColor = delNode-&gt;parent-&gt;color; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;right-&gt;color = tmpColor; LeftRotate(rbTree, broNode); RightRotate(rbTree, delNode-&gt;parent); continue; &#125; else &#123; if(delNode-&gt;parent-&gt;color == RED) &#123; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;color = RED; break; &#125; else &#123; broNode-&gt;color = RED; delNode = delNode-&gt;parent; continue; &#125; &#125; &#125; &#125; &#125; &#125; DelRbTreeNode(rbTree, delNode);&#125;void RbTreeDel(RbTree *rbTree, RbTreeNode *delNode)&#123; int tag = 0; while(tag != 2) &#123; if(delNode-&gt;left == rbTree-&gt;nil)//左子树为空 &#123; if(delNode-&gt;right == rbTree-&gt;nil)//右子树也为空 &#123; if(delNode-&gt;color == RED) &#123; RbTreeDelRedLeaf(rbTree, delNode); &#125; else if(delNode-&gt;color == BLACK) &#123; RbTreeDelBlackLeaf(rbTree, delNode); &#125; else &#123; printf(&quot;[%d][%s]ERR:node color err!\\n&quot;, __LINE__, __FUNCTION__); &#125; break; &#125; else//右子树不为空，此时仅有一种情况，即删除节点为黑色，右子节点为红色； &#123; RbTreeDelBlackNoleaf(rbTree, delNode); break; &#125; &#125; else//左子树不为空 &#123; if(delNode-&gt;right == rbTree-&gt;nil)//右子树为空 &#123; RbTreeDelBlackNoleaf(rbTree, delNode); break; &#125; else//左右子树都不为空 &#123; RbTreeNode *tempNode = delNode-&gt;right; while(tempNode != rbTree-&gt;nil) &#123; tempNode = tempNode-&gt;left; &#125; int tempKey = delNode-&gt;key; delNode-&gt;key = tempNode-&gt;key; delNode-&gt;value = tempNode-&gt;value; tempNode-&gt;key = tempKey; delNode = tempNode; tag++; &#125; &#125; &#125; return;&#125;RbTreeNode *RbTreeNodeCreate(int key, void* value)&#123; RbTreeNode *rbTreeNode = malloc(sizeof(RbTreeNode)); memset(rbTreeNode, 0 , sizeof(RbTreeNode)); rbTreeNode-&gt;key = key; rbTreeNode-&gt;value = value; return rbTreeNode;&#125;void PrintRbTreeNode(RbTreeNode *rbTreeNode)&#123; printf(&quot;Addr:%x|key:%d|color:%x|value:%s|left:%x|right:%x|parent:%x\\n&quot;, (int)rbTreeNode, rbTreeNode-&gt;key, rbTreeNode-&gt;color, rbTreeNode-&gt;value, (int)rbTreeNode-&gt;left, (int)rbTreeNode-&gt;right, (int)rbTreeNode-&gt;parent); return;&#125;int main()&#123; RbTree *rbTree1 = malloc(sizeof(RbTree)); rbTree1-&gt;root = NULL; rbTree1-&gt;nil = NULL; RbTreeNode *rbTreeNode1 = RbTreeNodeCreate(1234, &quot;hello&quot;); RbTreeNode *rbTreeNode2 = RbTreeNodeCreate(12, &quot;hellokitty&quot;); RbTreeNode *rbTreeNode3 = RbTreeNodeCreate(123, &quot;hellonimabidekitty&quot;); RbTreeInsert(rbTree1, rbTreeNode1); RbTreeInsert(rbTree1, rbTreeNode2); RbTreeInsert(rbTree1, rbTreeNode3); PrintRbTreeNode(rbTreeNode1); PrintRbTreeNode(rbTreeNode2); PrintRbTreeNode(rbTreeNode3); RbTreeDel(rbTree1, rbTreeNode1); PrintRbTreeNode(rbTreeNode1); PrintRbTreeNode(rbTreeNode2); PrintRbTreeNode(rbTreeNode3); return 0;&#125;","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 17-Oct-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 27-Oct-2021 */#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;//#include&lt;thread.h&gt;#define likely(x) __builtin_expect(!!(x), 1) //gcc内置函数, 帮助编译器分支优化#define unlikely(x) __builtin_expect(!!(x), 0)#define RED 1#define BLACK 2typedef struct RbTreeNode&#123; struct RbTreeNode *left; struct RbTreeNode *right; struct RbTreeNode *parent; unsigned char color; int key; void *value;&#125;RbTreeNode;typedef struct RbTree&#123; RbTreeNode *root; RbTreeNode *nil;&#125;RbTree;RbTreeNode* AllocRbTreeNode()&#123; RbTreeNode *rbTreeNode = NULL; rbTreeNode = malloc(sizeof(RbTreeNode)); if(rbTreeNode == NULL) return NULL; memset(rbTreeNode, 0, sizeof(RbTreeNode)); return rbTreeNode;&#125;void DelRbTreeNode(RbTree *rbTree, RbTreeNode *delNode)&#123; if(delNode-&gt;parent == rbTree-&gt;nil) free(delNode); if(delNode == delNode-&gt;parent-&gt;left) &#123; delNode-&gt;parent-&gt;left = rbTree-&gt;nil; &#125; else &#123; delNode-&gt;parent-&gt;right = rbTree-&gt;nil; &#125; free(delNode); return;&#125;void LeftRotate(RbTree *rbTree, RbTreeNode *rotNode)&#123; RbTreeNode *rightNode = rotNode-&gt;right; rotNode-&gt;right = rightNode-&gt;left; if(rightNode-&gt;left != rbTree-&gt;nil) &#123; rightNode-&gt;left-&gt;parent = rotNode; &#125; if(rotNode-&gt;parent == rbTree-&gt;nil) &#123; rbTree-&gt;root = rightNode; &#125; else if(rotNode == rotNode-&gt;parent-&gt;left) &#123; rotNode-&gt;parent-&gt;left = rightNode; rightNode-&gt;parent = rotNode-&gt;parent; &#125; else &#123; rotNode-&gt;parent-&gt;right = rightNode; rightNode-&gt;parent = rotNode-&gt;parent; &#125; rightNode-&gt;left = rotNode; rotNode-&gt;parent = rightNode; return;&#125;void RightRotate(RbTree *rbTree, RbTreeNode *rotNode)&#123; RbTreeNode *leftNode = rotNode-&gt;left; rotNode-&gt;left = leftNode-&gt;right; if(leftNode-&gt;right != rbTree-&gt;nil) &#123; leftNode-&gt;right-&gt;parent = rotNode; &#125; if(rotNode-&gt;parent == rbTree-&gt;nil) &#123; rbTree-&gt;root = leftNode; &#125; else if(rotNode == rotNode-&gt;parent-&gt;left) &#123; rotNode-&gt;parent-&gt;left = leftNode; leftNode-&gt;parent = rotNode-&gt;parent; &#125; else &#123; rotNode-&gt;parent-&gt;right = leftNode; leftNode-&gt;parent = rotNode-&gt;parent; &#125; leftNode-&gt;right = rotNode; rotNode-&gt;parent = leftNode;&#125;void RbTreeInsertFixup(RbTree *rbTree, RbTreeNode *fixNode)&#123; while((fixNode-&gt;parent != rbTree-&gt;nil) &amp;&amp; (fixNode-&gt;parent-&gt;color == RED)) &#123; if(fixNode-&gt;parent == fixNode-&gt;parent-&gt;parent-&gt;left) &#123; RbTreeNode *y = fixNode-&gt;parent-&gt;parent-&gt;right; if((y != rbTree-&gt;nil) &amp;&amp; (y-&gt;color == RED)) &#123; fixNode-&gt;parent-&gt;color = BLACK; y-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; fixNode = fixNode-&gt;parent-&gt;parent; &#125; else &#123; // LL型--&gt;右旋 if(fixNode == fixNode-&gt;parent-&gt;left) &#123; fixNode-&gt;parent-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; RightRotate(rbTree, fixNode-&gt;parent-&gt;parent); &#125; //LR型--左旋+右旋 else &#123; fixNode-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; LeftRotate(rbTree, fixNode-&gt;parent); RightRotate(rbTree, fixNode-&gt;parent); &#125; &#125; &#125; else &#123; RbTreeNode *y = fixNode-&gt;parent-&gt;parent-&gt;left; if((y != rbTree-&gt;nil) &amp;&amp; (y-&gt;color == RED)) &#123; fixNode-&gt;parent-&gt;color = BLACK; y-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; fixNode = fixNode-&gt;parent-&gt;parent; &#125; else &#123; //RR型--&gt;左旋 if(fixNode == fixNode-&gt;parent-&gt;right) &#123; fixNode-&gt;parent-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; LeftRotate(rbTree, fixNode-&gt;parent-&gt;parent); &#125; //RL型--&gt;右旋+左旋 else &#123; fixNode-&gt;color = BLACK; fixNode-&gt;parent-&gt;parent-&gt;color = RED; RightRotate(rbTree, fixNode-&gt;parent); LeftRotate(rbTree, fixNode); &#125; &#125; &#125; &#125; rbTree-&gt;root-&gt;color = BLACK; rbTree-&gt;root-&gt;parent = rbTree-&gt;nil;&#125;void RbTreeInsert(RbTree *rbTree, RbTreeNode *insertNode)&#123; //插入一个节点包括：寻找插入节点的位置；自平衡调整； RbTreeNode *x = rbTree-&gt;root; RbTreeNode *y = rbTree-&gt;nil; while(x != rbTree-&gt;nil) &#123; y = x; if(insertNode-&gt;key &lt; x-&gt;key) &#123; x = x-&gt;left; &#125; else if(insertNode-&gt;key &gt; x-&gt;key) &#123; x = x-&gt;right; &#125; else &#123; return; &#125; &#125; insertNode-&gt;parent = y; if(y == rbTree-&gt;nil) &#123; rbTree-&gt;root = insertNode; &#125; else if(insertNode-&gt;key &lt; y-&gt;key) &#123; y-&gt;left = insertNode; &#125; else &#123; y-&gt;right = insertNode; &#125; insertNode-&gt;left = rbTree-&gt;nil; insertNode-&gt;right = rbTree-&gt;nil; insertNode-&gt;color = RED; RbTreeInsertFixup(rbTree, insertNode);&#125;void RbTreeDelBlackNoleaf(RbTree *rbTree, RbTreeNode *delNode)&#123; RbTreeNode *delNodeSon; delNodeSon = (delNode-&gt;left == rbTree-&gt;nil)?(delNode-&gt;right):(delNode-&gt;left); if(unlikely((delNode-&gt;color != BLACK) || (delNodeSon-&gt;color != RED))) &#123; printf(&quot;[%d][%s]Not a rbTree!\\n&quot;, __LINE__, __FUNCTION__); &#125; if(delNode-&gt;parent == rbTree-&gt;nil) &#123; rbTree-&gt;root = delNode-&gt;left; &#125; else &#123; if(delNode == delNode-&gt;parent-&gt;left) &#123; delNode-&gt;parent-&gt;left = delNodeSon; &#125; else &#123; delNode-&gt;parent-&gt;right = delNodeSon; &#125; delNodeSon-&gt;parent = delNode-&gt;parent; delNodeSon-&gt;color = BLACK; free(delNode); &#125; return;&#125;void RbTreeDelRedLeaf(RbTree *rbTree, RbTreeNode *delNode)&#123; DelRbTreeNode(rbTree, delNode);&#125;void RbTreeDelBlackLeaf(RbTree *rbTree, RbTreeNode *delNode)&#123; while(delNode-&gt;parent != rbTree-&gt;nil) &#123; RbTreeNode *broNode; if(delNode == delNode-&gt;parent-&gt;left) &#123; broNode = delNode-&gt;parent-&gt;right; if(broNode-&gt;color == RED) &#123; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;color = BLACK; LeftRotate(rbTree, delNode-&gt;parent); continue; &#125; else &#123; if((broNode-&gt;right != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;right-&gt;color == RED)) &#123; int tmpColor = delNode-&gt;parent-&gt;color; delNode-&gt;parent-&gt;color = broNode-&gt;color; broNode-&gt;color = tmpColor; broNode-&gt;right-&gt;color = BLACK; LeftRotate(rbTree, delNode-&gt;parent); break; &#125; else &#123; if((broNode-&gt;left != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;left-&gt;color == RED)) &#123; int tmpColor = delNode-&gt;parent-&gt;color; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;left-&gt;color = tmpColor; RightRotate(rbTree, broNode); LeftRotate(rbTree, delNode-&gt;parent); continue; &#125; else &#123; if(delNode-&gt;parent-&gt;color == RED) &#123; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;color = RED; break; &#125; else &#123; broNode-&gt;color = RED; delNode = delNode-&gt;parent; continue; &#125; &#125; &#125; &#125; &#125; else &#123; broNode = delNode-&gt;parent-&gt;left; if(broNode-&gt;color == RED) &#123; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;color = BLACK; RightRotate(rbTree, delNode-&gt;parent); continue; &#125; else &#123; if((broNode-&gt;left != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;left-&gt;color == RED)) &#123; int tmpColor = delNode-&gt;parent-&gt;color; delNode-&gt;parent-&gt;color = broNode-&gt;color; broNode-&gt;color = tmpColor; broNode-&gt;left-&gt;color = BLACK; LeftRotate(rbTree, delNode-&gt;parent); break; &#125; else &#123; if((broNode-&gt;right != rbTree-&gt;nil) &amp;&amp; (broNode-&gt;right-&gt;color == RED)) &#123; int tmpColor = delNode-&gt;parent-&gt;color; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;right-&gt;color = tmpColor; LeftRotate(rbTree, broNode); RightRotate(rbTree, delNode-&gt;parent); continue; &#125; else &#123; if(delNode-&gt;parent-&gt;color == RED) &#123; delNode-&gt;parent-&gt;color = BLACK; broNode-&gt;color = RED; break; &#125; else &#123; broNode-&gt;color = RED; delNode = delNode-&gt;parent; continue; &#125; &#125; &#125; &#125; &#125; &#125; DelRbTreeNode(rbTree, delNode);&#125;void RbTreeDel(RbTree *rbTree, RbTreeNode *delNode)&#123; int tag = 0; while(tag != 2) &#123; if(delNode-&gt;left == rbTree-&gt;nil)//左子树为空 &#123; if(delNode-&gt;right == rbTree-&gt;nil)//右子树也为空 &#123; if(delNode-&gt;color == RED) &#123; RbTreeDelRedLeaf(rbTree, delNode); &#125; else if(delNode-&gt;color == BLACK) &#123; RbTreeDelBlackLeaf(rbTree, delNode); &#125; else &#123; printf(&quot;[%d][%s]ERR:node color err!\\n&quot;, __LINE__, __FUNCTION__); &#125; break; &#125; else//右子树不为空，此时仅有一种情况，即删除节点为黑色，右子节点为红色； &#123; RbTreeDelBlackNoleaf(rbTree, delNode); break; &#125; &#125; else//左子树不为空 &#123; if(delNode-&gt;right == rbTree-&gt;nil)//右子树为空 &#123; RbTreeDelBlackNoleaf(rbTree, delNode); break; &#125; else//左右子树都不为空 &#123; RbTreeNode *tempNode = delNode-&gt;right; while(tempNode != rbTree-&gt;nil) &#123; tempNode = tempNode-&gt;left; &#125; int tempKey = delNode-&gt;key; delNode-&gt;key = tempNode-&gt;key; delNode-&gt;value = tempNode-&gt;value; tempNode-&gt;key = tempKey; delNode = tempNode; tag++; &#125; &#125; &#125; return;&#125;RbTreeNode *RbTreeNodeCreate(int key, void* value)&#123; RbTreeNode *rbTreeNode = malloc(sizeof(RbTreeNode)); memset(rbTreeNode, 0 , sizeof(RbTreeNode)); rbTreeNode-&gt;key = key; rbTreeNode-&gt;value = value; return rbTreeNode;&#125;void PrintRbTreeNode(RbTreeNode *rbTreeNode)&#123; printf(&quot;Addr:%x|key:%d|color:%x|value:%s|left:%x|right:%x|parent:%x\\n&quot;, (int)rbTreeNode, rbTreeNode-&gt;key, rbTreeNode-&gt;color, rbTreeNode-&gt;value, (int)rbTreeNode-&gt;left, (int)rbTreeNode-&gt;right, (int)rbTreeNode-&gt;parent); return;&#125;int main()&#123; RbTree *rbTree1 = malloc(sizeof(RbTree)); rbTree1-&gt;root = NULL; rbTree1-&gt;nil = NULL; RbTreeNode *rbTreeNode1 = RbTreeNodeCreate(1234, &quot;hello&quot;); RbTreeNode *rbTreeNode2 = RbTreeNodeCreate(12, &quot;hellokitty&quot;); RbTreeNode *rbTreeNode3 = RbTreeNodeCreate(123, &quot;hellonimabidekitty&quot;); RbTreeInsert(rbTree1, rbTreeNode1); RbTreeInsert(rbTree1, rbTreeNode2); RbTreeInsert(rbTree1, rbTreeNode3); PrintRbTreeNode(rbTreeNode1); PrintRbTreeNode(rbTreeNode2); PrintRbTreeNode(rbTreeNode3); RbTreeDel(rbTree1, rbTreeNode1); PrintRbTreeNode(rbTreeNode1); PrintRbTreeNode(rbTreeNode2); PrintRbTreeNode(rbTreeNode3); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"int型数据bit反转","slug":"int型数据bit反转","date":"2021-07-25T03:17:54.000Z","updated":"2021-10-17T06:29:57.424Z","comments":true,"path":"2021/07/25/int型数据bit反转/","link":"","permalink":"http://example.com/2021/07/25/int%E5%9E%8B%E6%95%B0%E6%8D%AEbit%E5%8F%8D%E8%BD%AC/","excerpt":"问题背景:计算int型数据bit位前后顺序反转后的数值，例如：input：22output：1744830464 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 18-Jul-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 25-Jul-2021 */#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define BYTELEN 8void TransformInt2Bit(unsigned int input, unsigned int* bitArr)&#123; for(int loop = 0; loop &lt; 32; loop++) &#123; bitArr[loop] = input % 2; input = (input&gt;&gt;1); &#125;&#125;void TransformBit2Int(unsigned int* output, unsigned int *bitArr)&#123; for(int loop = 0; loop &lt; 32; loop++) &#123; *output += bitArr[loop] * pow(2, loop); &#125;&#125;void ReverseArr(unsigned int *arr, unsigned int size)&#123; int temp = 0; for(int loop = 0; loop &lt; (size/2); loop++) &#123; temp = arr[loop]; arr[loop] = arr[size-1-loop]; arr[size-1-loop] = temp; &#125;&#125;int main()&#123; unsigned int input; scanf(&quot;%d&quot;, &amp;input); unsigned bitArr[BYTELEN*sizeof(input)]; TransformInt2Bit(input, bitArr); ReverseArr(bitArr, sizeof(arr)/sizeof(int)); unsigned int output = 0; TransformBit2Int(&amp;output, bitArr); printf(&quot;%u\\n&quot;, output); return 0;&#125;","text":"问题背景:计算int型数据bit位前后顺序反转后的数值，例如：input：22output：1744830464 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 18-Jul-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 25-Jul-2021 */#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define BYTELEN 8void TransformInt2Bit(unsigned int input, unsigned int* bitArr)&#123; for(int loop = 0; loop &lt; 32; loop++) &#123; bitArr[loop] = input % 2; input = (input&gt;&gt;1); &#125;&#125;void TransformBit2Int(unsigned int* output, unsigned int *bitArr)&#123; for(int loop = 0; loop &lt; 32; loop++) &#123; *output += bitArr[loop] * pow(2, loop); &#125;&#125;void ReverseArr(unsigned int *arr, unsigned int size)&#123; int temp = 0; for(int loop = 0; loop &lt; (size/2); loop++) &#123; temp = arr[loop]; arr[loop] = arr[size-1-loop]; arr[size-1-loop] = temp; &#125;&#125;int main()&#123; unsigned int input; scanf(&quot;%d&quot;, &amp;input); unsigned bitArr[BYTELEN*sizeof(input)]; TransformInt2Bit(input, bitArr); ReverseArr(bitArr, sizeof(arr)/sizeof(int)); unsigned int output = 0; TransformBit2Int(&amp;output, bitArr); printf(&quot;%u\\n&quot;, output); return 0;&#125;","categories":[{"name":"习题","slug":"习题","permalink":"http://example.com/categories/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}]},{"title":"C 解一元一次方程","slug":"C解一元一次方程","date":"2021-07-19T18:43:58.000Z","updated":"2021-10-17T06:30:11.369Z","comments":true,"path":"2021/07/20/C解一元一次方程/","link":"","permalink":"http://example.com/2021/07/20/C%E8%A7%A3%E4%B8%80%E5%85%83%E4%B8%80%E6%AC%A1%E6%96%B9%E7%A8%8B/","excerpt":"问题背景：实现一元一次方程的计算，例如：input：3a+3=9output:a=2 note:给出的一元一次方程中没有括号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 20-Jul-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 25-Jul-2021 *//*//实现解一元一次方程//step1 接收输入，并转换成需要的数据格式//step2 算法实现//step3 输出结果，并清理程序资源1 接收的输入格式为一行字符串，选择将其存储在数组中 声明需要的数组资源，类型大小； 使用getc函数接收输入并存储在数组中； 当接收到‘\\n’时表示结束； 将存储在数组中的输入打印出来检测是否正确；2 算法思路就是将一元一次表达式转换为AX+B=0的形式。然后直接计算X=-(B/A)即可； 因此需要遍历表达式中的元素进行区分合并同类项，根据项的特点可以将数组中存储的内容分为三类，分别是符号、数字和字母；实现时根据ASCII码进行区分； 此处设计两个栈，A栈和B栈，分别存储计算系数A和B时的元素，将数组中的元素从右到左遍历， 1 若元素是字母则表示该项为AX，即需要把当前栈指向A栈，否则指向B栈 2 若元素是数字，则直接存入当前栈 3 若元素是符号，则更新符号变量，并计算当前栈内元素组成的数字大小，累加到系数A或B，然后清空当前栈并释放当前栈*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#define POPNUM_IS_WORD(popNum) (Int2Char(popNum) &gt;= &#x27;a&#x27;) &amp;&amp; (Int2Char(popNum) &lt;= &#x27;z&#x27;)#define POPNUM_IS_NUM(popNum) (Int2Char(popNum) &lt;= &#x27;9&#x27;) &amp;&amp; (Int2Char(popNum) &gt;= &#x27;0&#x27;)#define POPNUM_IS_EQUAL(popNum) (Int2Char(popNum) == &#x27;=&#x27;)#define POPNUM_IS_PLUS(popNum) (Int2Char(popNum) == &#x27;+&#x27;)#define POPNUM_IS_SUBSTRACT(popNum) (Int2Char(popNum) == &#x27;-&#x27;)int StoreInput(char *arr, int size)&#123; for(int loop = 0; loop &lt; size; loop++) &#123; scanf(&quot;%c&quot;, arr+loop); if(*(arr+loop) == &#x27;\\n&#x27;) &#123; return loop; &#125; &#125; printf(&quot;The input is too long!\\n&quot;); return 0;&#125;typedef struct node&#123; int num; struct node* next;&#125;node;void NodeFree(node* head)&#123; node* tNode; while(head-&gt;next != NULL) &#123; tNode = head-&gt;next; free(head); head = tNode; &#125; return;&#125;node* GetCurNode(node* head)&#123; node* temp = head; while(temp-&gt;next != NULL) &#123; temp = temp-&gt;next; &#125; return temp;&#125;void NodePush(node* head, int num)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return; &#125; node* curNode = GetCurNode(head); node* nextNode = (node*)malloc(sizeof(node)); nextNode-&gt;num = num; nextNode-&gt;next = NULL; curNode-&gt;next = nextNode;&#125;int NodePop(node* head)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return -1; &#125; int popNum = 0; node* prevNode = head; if(prevNode-&gt;next == NULL) &#123; popNum = prevNode-&gt;num; //printf(&quot;%d\\n&quot;, popNum); free(prevNode); return popNum; &#125; node* relNode = prevNode-&gt;next; while(relNode-&gt;next != NULL) &#123; prevNode = prevNode-&gt;next; relNode = prevNode-&gt;next; &#125; popNum = relNode-&gt;num; free(relNode); prevNode-&gt;next = NULL; return popNum;;&#125;void NodePrint(node* head)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return; &#125; node* curNode = head; while(curNode-&gt;next != NULL) &#123; curNode = curNode-&gt;next; &#125;&#125;int char2Int(char c)&#123; return (int)(c-&#x27;0&#x27;);&#125;char Int2Char(int num)&#123; return (char)(num+&#x27;0&#x27;);&#125;int GetCurStackValue(int curStackLen, node* curStack)&#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; return temp;&#125;void UpdateCoef(node* curStack, node* stackA, node* stackB, double* coefA, double* coefB, int temp, int coefSym)&#123; if(curStack == stackA) &#123; if(temp != 0) *coefA += coefSym * temp; else *coefA += coefSym; //printf(&quot;coefA:%f\\n&quot;, *coefA); &#125; if(curStack == stackB) &#123; *coefB += coefSym * temp; //printf(&quot;coefB:%f\\n&quot;, *coefB); &#125;&#125;void UpdateCoefFirstTerm(int loop, node* curStack, node* stackA, node* stackB, double* coefA, double* coefB, int coefSym, int curStackLen)&#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; if(curStack == stackA) &#123; *coefA += (coefSym) * temp; &#125; if(curStack == stackB) &#123; *coefB += (coefSym) * temp; &#125; NodeFree(curStack); curStack = stackB; curStackLen = 0;&#125;void calcCoef(node* head, int pos, double* coefA, double* coefB, char* unKownNum)&#123; node stackA, stackB; stackA.num = 0; stackA.next = NULL; stackB.num = 0; stackB.next = NULL; node* curStack = &amp;stackB; char popNum; int curStackLen = 0, coefSym = -1; for(int loop = pos; loop &gt; 0; loop--) &#123; popNum = (char)NodePop(head); if(POPNUM_IS_WORD(popNum)) &#123; curStack = &amp;stackA; *unKownNum = Int2Char(popNum); if(loop == 1) *coefA += 1; continue; &#125; if(POPNUM_IS_NUM(popNum)) &#123; NodePush(curStack, (int)popNum); curStackLen++; if(loop == 1) &#123; UpdateCoefFirstTerm(loop, curStack, &amp;stackA, &amp;stackB, coefA, coefB, coefSym, curStackLen); &#125; continue; &#125; if(POPNUM_IS_EQUAL(popNum)) &#123; int temp = GetCurStackValue(curStackLen, curStack); //printf(&quot;=|temp:%d\\n&quot;, temp); UpdateCoef(curStack, &amp;stackA, &amp;stackB, coefA, coefB, temp, coefSym); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; coefSym = 1; &#125; if(POPNUM_IS_SUBSTRACT(popNum)) &#123; int temp = GetCurStackValue(curStackLen, curStack); coefSym = coefSym * (-1); UpdateCoef(curStack, &amp;stackA, &amp;stackB, coefA, coefB, temp, coefSym); //printf(&quot;coefA:%f\\ncoefB:%f\\n&quot;, *coefA, *coefB); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; if(POPNUM_IS_PLUS(popNum)) &#123; int temp = GetCurStackValue(curStackLen, curStack); UpdateCoef(curStack, &amp;stackA, &amp;stackB, coefA, coefB, temp, coefSym); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; &#125;&#125;int main()&#123; char arr[30]; int pos; pos = StoreInput(arr, 30); node *head = (node*)malloc(sizeof(node)); head-&gt;num = 0; head-&gt;next = NULL; for(int loop = 0; loop &lt; pos; loop++) &#123; NodePush(head, char2Int(*(arr+loop))); &#125; double coefA = 0, coefB = 0; char unKownNum; calcCoef(head, pos, &amp;coefA, &amp;coefB, &amp;unKownNum); printf(&quot;%c=%.3f\\n&quot;, unKownNum, (-coefB/coefA)); NodeFree(head); free(head); return 0;&#125;","text":"问题背景：实现一元一次方程的计算，例如：input：3a+3=9output:a=2 note:给出的一元一次方程中没有括号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 20-Jul-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 25-Jul-2021 *//*//实现解一元一次方程//step1 接收输入，并转换成需要的数据格式//step2 算法实现//step3 输出结果，并清理程序资源1 接收的输入格式为一行字符串，选择将其存储在数组中 声明需要的数组资源，类型大小； 使用getc函数接收输入并存储在数组中； 当接收到‘\\n’时表示结束； 将存储在数组中的输入打印出来检测是否正确；2 算法思路就是将一元一次表达式转换为AX+B=0的形式。然后直接计算X=-(B/A)即可； 因此需要遍历表达式中的元素进行区分合并同类项，根据项的特点可以将数组中存储的内容分为三类，分别是符号、数字和字母；实现时根据ASCII码进行区分； 此处设计两个栈，A栈和B栈，分别存储计算系数A和B时的元素，将数组中的元素从右到左遍历， 1 若元素是字母则表示该项为AX，即需要把当前栈指向A栈，否则指向B栈 2 若元素是数字，则直接存入当前栈 3 若元素是符号，则更新符号变量，并计算当前栈内元素组成的数字大小，累加到系数A或B，然后清空当前栈并释放当前栈*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#define POPNUM_IS_WORD(popNum) (Int2Char(popNum) &gt;= &#x27;a&#x27;) &amp;&amp; (Int2Char(popNum) &lt;= &#x27;z&#x27;)#define POPNUM_IS_NUM(popNum) (Int2Char(popNum) &lt;= &#x27;9&#x27;) &amp;&amp; (Int2Char(popNum) &gt;= &#x27;0&#x27;)#define POPNUM_IS_EQUAL(popNum) (Int2Char(popNum) == &#x27;=&#x27;)#define POPNUM_IS_PLUS(popNum) (Int2Char(popNum) == &#x27;+&#x27;)#define POPNUM_IS_SUBSTRACT(popNum) (Int2Char(popNum) == &#x27;-&#x27;)int StoreInput(char *arr, int size)&#123; for(int loop = 0; loop &lt; size; loop++) &#123; scanf(&quot;%c&quot;, arr+loop); if(*(arr+loop) == &#x27;\\n&#x27;) &#123; return loop; &#125; &#125; printf(&quot;The input is too long!\\n&quot;); return 0;&#125;typedef struct node&#123; int num; struct node* next;&#125;node;void NodeFree(node* head)&#123; node* tNode; while(head-&gt;next != NULL) &#123; tNode = head-&gt;next; free(head); head = tNode; &#125; return;&#125;node* GetCurNode(node* head)&#123; node* temp = head; while(temp-&gt;next != NULL) &#123; temp = temp-&gt;next; &#125; return temp;&#125;void NodePush(node* head, int num)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return; &#125; node* curNode = GetCurNode(head); node* nextNode = (node*)malloc(sizeof(node)); nextNode-&gt;num = num; nextNode-&gt;next = NULL; curNode-&gt;next = nextNode;&#125;int NodePop(node* head)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return -1; &#125; int popNum = 0; node* prevNode = head; if(prevNode-&gt;next == NULL) &#123; popNum = prevNode-&gt;num; //printf(&quot;%d\\n&quot;, popNum); free(prevNode); return popNum; &#125; node* relNode = prevNode-&gt;next; while(relNode-&gt;next != NULL) &#123; prevNode = prevNode-&gt;next; relNode = prevNode-&gt;next; &#125; popNum = relNode-&gt;num; free(relNode); prevNode-&gt;next = NULL; return popNum;;&#125;void NodePrint(node* head)&#123; if(head == NULL) &#123; printf(&quot;head is NULL!\\n&quot;); return; &#125; node* curNode = head; while(curNode-&gt;next != NULL) &#123; curNode = curNode-&gt;next; &#125;&#125;int char2Int(char c)&#123; return (int)(c-&#x27;0&#x27;);&#125;char Int2Char(int num)&#123; return (char)(num+&#x27;0&#x27;);&#125;int GetCurStackValue(int curStackLen, node* curStack)&#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; return temp;&#125;void UpdateCoef(node* curStack, node* stackA, node* stackB, double* coefA, double* coefB, int temp, int coefSym)&#123; if(curStack == stackA) &#123; if(temp != 0) *coefA += coefSym * temp; else *coefA += coefSym; //printf(&quot;coefA:%f\\n&quot;, *coefA); &#125; if(curStack == stackB) &#123; *coefB += coefSym * temp; //printf(&quot;coefB:%f\\n&quot;, *coefB); &#125;&#125;void UpdateCoefFirstTerm(int loop, node* curStack, node* stackA, node* stackB, double* coefA, double* coefB, int coefSym, int curStackLen)&#123; int temp = 0; for(int loop = 0; loop &lt; curStackLen; loop++) &#123; temp += pow(10, curStackLen-1-loop) * NodePop(curStack); &#125; if(curStack == stackA) &#123; *coefA += (coefSym) * temp; &#125; if(curStack == stackB) &#123; *coefB += (coefSym) * temp; &#125; NodeFree(curStack); curStack = stackB; curStackLen = 0;&#125;void calcCoef(node* head, int pos, double* coefA, double* coefB, char* unKownNum)&#123; node stackA, stackB; stackA.num = 0; stackA.next = NULL; stackB.num = 0; stackB.next = NULL; node* curStack = &amp;stackB; char popNum; int curStackLen = 0, coefSym = -1; for(int loop = pos; loop &gt; 0; loop--) &#123; popNum = (char)NodePop(head); if(POPNUM_IS_WORD(popNum)) &#123; curStack = &amp;stackA; *unKownNum = Int2Char(popNum); if(loop == 1) *coefA += 1; continue; &#125; if(POPNUM_IS_NUM(popNum)) &#123; NodePush(curStack, (int)popNum); curStackLen++; if(loop == 1) &#123; UpdateCoefFirstTerm(loop, curStack, &amp;stackA, &amp;stackB, coefA, coefB, coefSym, curStackLen); &#125; continue; &#125; if(POPNUM_IS_EQUAL(popNum)) &#123; int temp = GetCurStackValue(curStackLen, curStack); //printf(&quot;=|temp:%d\\n&quot;, temp); UpdateCoef(curStack, &amp;stackA, &amp;stackB, coefA, coefB, temp, coefSym); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; coefSym = 1; &#125; if(POPNUM_IS_SUBSTRACT(popNum)) &#123; int temp = GetCurStackValue(curStackLen, curStack); coefSym = coefSym * (-1); UpdateCoef(curStack, &amp;stackA, &amp;stackB, coefA, coefB, temp, coefSym); //printf(&quot;coefA:%f\\ncoefB:%f\\n&quot;, *coefA, *coefB); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; if(POPNUM_IS_PLUS(popNum)) &#123; int temp = GetCurStackValue(curStackLen, curStack); UpdateCoef(curStack, &amp;stackA, &amp;stackB, coefA, coefB, temp, coefSym); NodeFree(curStack); curStack = &amp;stackB; curStackLen = 0; &#125; &#125;&#125;int main()&#123; char arr[30]; int pos; pos = StoreInput(arr, 30); node *head = (node*)malloc(sizeof(node)); head-&gt;num = 0; head-&gt;next = NULL; for(int loop = 0; loop &lt; pos; loop++) &#123; NodePush(head, char2Int(*(arr+loop))); &#125; double coefA = 0, coefB = 0; char unKownNum; calcCoef(head, pos, &amp;coefA, &amp;coefB, &amp;unKownNum); printf(&quot;%c=%.3f\\n&quot;, unKownNum, (-coefB/coefA)); NodeFree(head); free(head); return 0;&#125;","categories":[{"name":"习题","slug":"习题","permalink":"http://example.com/categories/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}]},{"title":"手把手教你写Makefile和CMakelists.txt","slug":"Makefile及CMake教程","date":"2021-06-25T15:22:55.000Z","updated":"2021-06-29T13:42:53.367Z","comments":true,"path":"2021/06/25/Makefile及CMake教程/","link":"","permalink":"http://example.com/2021/06/25/Makefile%E5%8F%8ACMake%E6%95%99%E7%A8%8B/","excerpt":"入职后开始接触了Linux环境下的代码，而且是一个代码量10W+的巨型工程，刚面对这样打的项目时总是对其中重重的文件目录感到惊讶，这么多的文件是怎么变成最后的可执行文件的？ 之前在学校或者个人学习的时候写的代码都是比较简单的，一个目录下若干个c文件，编译时直接使用gcc工具一步执行gcc main.c -o main就完事了，但是面对这种多目录多源文件的项目如果还使用这种方法的话明显生产效率是极低的。由于不同的项目在进行编译时都使用相同的编译指令，只是路径和文件名不同，所以自然想到应该可以编写脚本实现编译自动化，经过学习发现原来有一种专门的脚本语言用来解决这件事，就是今天学习的内容Makefile和CMakelists.txt。 什么是Makefile首先说下Makefile，Makefile就是包含编译指令的一个脚本，Makefile需要和make搭配使用，make是Linux平台下的一个工具，通过它可以执行Makefile中的编译指令以完成工程的编译。make和Makefile的关系可以用bash和shell脚本做类比，脚本中按照脚本的规定语法写好了一些指令，然后通过对应的执行命令将脚本中的一系列指令执行完成。 接下来我们就来看下书写Makefile脚本的语法规则吧，首先我们都知道生成一个可执行文件需要有源文件，而源文件多数也都需要依赖文件，例如头文件等，Makefile中也必须遵循这样的原则。 makefile的语法规则之一就是：(以C语言项目为例，使用GCC工具，如果是C++项目则使用G++工具) targetFile:sourceFilegcc -[E][S][C][ ] sourceFile -o targetFile # gcc -E 表示只进行预编译，得到的目标文件为后缀为i的预编译文件（预编译执行的操作包括头展开，宏替换以及条件编译优化） # gcc -S 表示进行预编译和汇编，得到后缀为s的汇编文件（汇编将预编译的代码转换为汇编代码）","text":"入职后开始接触了Linux环境下的代码，而且是一个代码量10W+的巨型工程，刚面对这样打的项目时总是对其中重重的文件目录感到惊讶，这么多的文件是怎么变成最后的可执行文件的？ 之前在学校或者个人学习的时候写的代码都是比较简单的，一个目录下若干个c文件，编译时直接使用gcc工具一步执行gcc main.c -o main就完事了，但是面对这种多目录多源文件的项目如果还使用这种方法的话明显生产效率是极低的。由于不同的项目在进行编译时都使用相同的编译指令，只是路径和文件名不同，所以自然想到应该可以编写脚本实现编译自动化，经过学习发现原来有一种专门的脚本语言用来解决这件事，就是今天学习的内容Makefile和CMakelists.txt。 什么是Makefile首先说下Makefile，Makefile就是包含编译指令的一个脚本，Makefile需要和make搭配使用，make是Linux平台下的一个工具，通过它可以执行Makefile中的编译指令以完成工程的编译。make和Makefile的关系可以用bash和shell脚本做类比，脚本中按照脚本的规定语法写好了一些指令，然后通过对应的执行命令将脚本中的一系列指令执行完成。 接下来我们就来看下书写Makefile脚本的语法规则吧，首先我们都知道生成一个可执行文件需要有源文件，而源文件多数也都需要依赖文件，例如头文件等，Makefile中也必须遵循这样的原则。 makefile的语法规则之一就是：(以C语言项目为例，使用GCC工具，如果是C++项目则使用G++工具) targetFile:sourceFilegcc -[E][S][C][ ] sourceFile -o targetFile # gcc -E 表示只进行预编译，得到的目标文件为后缀为i的预编译文件（预编译执行的操作包括头展开，宏替换以及条件编译优化） # gcc -S 表示进行预编译和汇编，得到后缀为s的汇编文件（汇编将预编译的代码转换为汇编代码） # gcc -c 表示进行预编译、汇编和编译，得到后缀为o的二进制文件（编译将汇编代码转换为二进制机器语言） # gcc不带参数表示直接进行预编译、汇编、编译和链接，得到可执行文件 其中第一行定义了目标文件和源文件，中间用冒号隔开，第二行先用TAB键置空位，然后给出了具体的实现指令。 该命令只有在目标文件不存在，或目标比依赖的文件更旧，才会被执行。 当我们的工程中在同一目录下出现了多个C源文件时，则需重复上面两行指令依次生成.o文件最后链接成可执行文件。那么为了减少这种重复度极高的代码的书写，makefile语法中提供了一种设置替换的方式，可以将所有的同类型文件用一个变量来表示。 OBJ=a.o b.o c.o TAR=main 这样Makefile中所有出现a.o b.o c.o的地方就都可以用$(OBJ)来代替，所有出现main的地方都可以用$(TAR)表示，$(变量名)为变量的使用方式。 另外还可以用+=进行追加使变量可以适用于不同的场景。:=则表示恒等于，使用恒等于设置的变量就不能在进行追加了。 除此以外，还有一些固定变量，**%.c表示任意的.c文件，%.o表示任意的.o文件， .c表示所有的.c文件，.o表示所有的.o文件，$@表示所有的目标文件，$^表示所有的依赖文件，$&lt;表示所有依赖文件的第一个**。 通过这些变量使得我们的Makefile大大精简，同时还增强了Makefile在不同工程下的适用性。 最后在Makefile文件中还会集成一些和编译无关的操作我们希望在进行编译时或之前或之后同时进行的，例如编译之前先清除遗留的中间文件而重新生成覆盖，Makefile同样提供了一种伪目标的方式来实现。 .PHONY:clear clear: rm -rf main.o main .PHONY后面的target（即冒号之前的文件）表示的也是一个伪造的target, 而不是真实存在的文件target 总结一下，Makefile的编写其实就包括三步，第一步，指定目标文件和依赖文件；第二步，给出从依赖文件到目标文件的实现指令；第三步，进行变量替换； 华丽的分割线 CMakelists.txt又是什么东西?因为不同平台下的Makefile书写规则是不一样的，Makefile只适用于类UNIX系统下的编译，如果是在Windows环境下则需要重新编写Makefile。cmake就是为了解决跨平台编译的问题，使用cmake工具，可以自动生成适应平台的Makefile。 同样的，在单目录的场景下，CMakelists.txt的语法如下 CMAKE_MINIMUM_REQUIRED(3.10) PROJECT(main) AUX_SOURCE_DIR(./ DIR_SRC) ADD_EXECUTABLE(main ${DIR_SRC}) 只需要三行代码，第一行指定支持的cmake最低版本；第二行给工程命名；第三行将目录下所有源文件打包成变量，第四行生成可执行文件； 如果是多目录下，比如一个库文件目录和一个源文件目录的话，则需要在每个目录下面都编写一个CMakeLists.txt，一共三个，分别是源文件目录，库文件目录和根目录 其中源文件目录src下的CMakeListx.txt内容如下 AUX_SOURCE_DIRECTORY(./ DIR_SRC) ADD_EXECUTABLE(main ${DIR_SRC}) TARGET_LINK_LIBRARIES(main mylib) 库文件目录mylib下面的CMakeLists.txt内容如下 AUX_SOURCE_DIRECTORY(./ DIR_LIB) ADD_LIBRARY(mylib ${DIR_LIB}) 根目录下的CMakeLists.txt内容如下 CMAKE_MINIMUM_REQUIRED(3.10) PROJECT(main) ADD_SUBDIRECTORY(./src) ADD_SUBDIRECTORY(./mylib) 这是库目录和源文件目录分离的场景，如果说只有一个源文件没必要新建一个源文件目录即不存在源文件目录的情况下，库目录下的CMakeLists.txt不变，根目录下的CMakeLists.txt内容如下 CMAKE_MINIMUM_REQUIRED(3.10) PROJECT(main) ADD_SUBDIRECTORY(./mylib) AUX_SOURCE_DIRECTORY(./ DIR_SRC) ADD_EXECUTABLE(main ${DIR_SRC}) TARGET_LINK_LIBRARIES(main mylib) 实际上就是把原来根目录和源文件目录下的CMakeLists.txt合并了 以上是自己学习CMake的一点学习记录，总结下来发现也完全不难，只需要理解两个场景单目录和多目录下的编写方式就可以了，关键的语法不超过10行，CMake的知识点还有很多，具体详情可以在网上搜索。总之，CMake可以让我们不用去编写复杂的Makefile，并且跨平台，是个非常强大并值得一学的工具。 如果有写的不对的地方，希望能留言指正，谢谢阅读。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"编译技术","slug":"编译技术","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"}]}],"categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"习题","permalink":"http://example.com/categories/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"编译技术","slug":"编译技术","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"}]}